classdef Encoder < handle

	properties (SetAccess = public)%private)
		layers;%(4) = struct( 'name', [], 'locations', [], 'sRFRc', [], 'sRFKc', [], 'sRFRs', [], 'sRFKs', [] );
		SpatialModel;
		TemporalModel;
		activityParams;
	end


	methods
		
		function obj = Encoder(paramFolder, HsBe1)
			%% Constructor function
			%	paramFolder:		folder containing cell parameters

			if( nargin() < 1 || isempty(paramFolder) )
				paramFolder = './Parameters/';
			end
			if( nargin() < 2 || isempty(HsBe1) )
				HsBe1 = false;
			end

			obj.TemporalModel = TemporalRF();
			
			obj.layers = struct( 'name', cell(1,4), 'locations', [], 'sRFParams', [], 'tRFParams', [] );
			names = {'POn', 'POff', 'MOn', 'MOff'};
			[obj.layers.name] = names{:};

			% obj.SpatialModel = CronerKaplanRGCModel( 'dataSetToFit', 'raw', 'fitIntercept', false, 'randomizeCenterRadii', true, 'randomizeCenterSensitivities', true, 'randomizeSurroundRadii', true, 'randomizeSurroundSensitivities', true );
			obj.SpatialModel = CronerKaplanRGCModel( 'dataSetToFit', 'raw', 'fitIntercept', false, 'randomizeCenterRadii', false, 'randomizeCenterSensitivities', false, 'randomizeSurroundRadii', false, 'randomizeSurroundSensitivities', false );

			for( k =  1 : size(obj.layers,2) )
				fprintf( 'k = %d\ncellType = %s\n\n', k, names{k} );

				% get cell locations
				if( exist( fullfile( paramFolder, ['Mosaic_' names{k} '_Radius20.0deg_maxMovPrctile20.mat'] ), 'file' ) )
					mosaic_ = load( fullfile( paramFolder, ['Mosaic_' names{k} '_Radius20.0deg_maxMovPrctile20.mat'] ), 'rfPositions', 'spacing' );
					obj.layers(k).locations = mosaic_.rfPositions;
					obj.layers(k).spacing = mosaic_.spacing;
				else
					obj.layers(k).locations = WatsonRGCModel.CreateMosaic(20, names{k}, 'saveFolder', paramFolder, 'maxIterations', 3000);
					obj.layers(k).spacing = WatsonRGCModel.AveSpacingInMosaic(obj.layers(k).locations);
				end

				% get spatial RF parameters
				if( exist( fullfile( paramFolder, ['SpatialRFParams_', names{k}, '.mat'] ), 'file' ) )
					obj.layers(k).sRFParams = load( fullfile( paramFolder, ['SpatialRFParams_', names{k}, '.mat'] ), 'sRFParams' );
					obj.layers(k).sRFParams = obj.layers(k).sRFParams.sRFParams;
				else
					% sRFParams = obj.SpatialModel.SynthesizeRFParams( sqrt(sum(obj.layers(k).locations.^2,2))', names{k} );
					% compute temporal equivalent eccentricity
					ecc_ = 0:0.001:120;
					[~, spacing_] = WatsonRGCModel.RFSpacingDensityMeridian( ecc_, WatsonRGCModel.enumeratedMeridianNames{1}, names{k} );   % temporal meridian
					[~, spacing] = WatsonRGCModel.RFSpacingDensity(obj.layers(k).locations, obj.layers(k).name);
					temporalEccDegs = interp1( spacing_, ecc_, spacing, 'linear', 'extrap' );
					
					sRFParams = obj.SpatialModel.Spacing2RFParams(names{k}, obj.layers(k).spacing', temporalEccDegs);
					obj.layers(k).sRFParams = sRFParams;
					save( fullfile( paramFolder, ['SpatialRFParams_', names{k}, '.mat'] ), 'sRFParams' );
				end

				% get temporal RF parameters
				obj.layers(k).tRFParams = obj.TemporalModel.SynthesizeParams( names{k}, size(obj.layers(k).locations, 1), true, '97', HsBe1 );
			end
		end


		function obj = LoadExampleCellsActivities(obj, dataFile)
			%% Load linear responses generated by Encoder.ExampleCells() 

			if( nargin() < 2 || isempty(dataFile) )
				dataFile = '../../Data/Simulated Activities/Noise & Grating Simulated Separately/Noise & Grating Simulated Separately.mat';
			end

			load(dataFile);
			for(iL = 1 : size(obj.layers,2))
				obj.layers(iL).idxAllCells = idxAllCells(iL,:);				% index of all cells covering an annulus at different eccentricities
				obj.layers(iL).idxExampleCells = idxExampleCells(iL,:);		% index of example cells covering an annulus at different eccentricities
				obj.layers(iL).nAllCells = [nAllCells{iL,:}];
				obj.layers(iL).nExampleCells = [nExampleCells{iL,:}];

				obj.layers(iL).LFR = LFR(:,iL)';
				obj.activityParams.conditions = conditions;
				obj.activityParams.timeline = time{1};
				obj.activityParams.trials = trials(trialsIdx{1});
            end
		end


		function FR = AddInternalNoise(obj, FR, loadFolder)
			
			if(~isfield(obj.activityParams, 'internalNoise'))
				if(~exist('loadFolder', 'var'))
					fprintf('Please call AddInternalNoise([], loadFolder) first to load internal noise!\n')
					return;
				end
				load(loadFolder);
				frBG = max(0, cat(1, LFR{[obj.activityParams.conditions.sf] == 0, :}));
				obj.activityParams.internalNoise = mean(reshape(frBG(:, end-199:end, :), 1, [])) / 3;		% 1/3 of the external noise acitivity
			end

			% if(strcmpi(cellType, 'all'))
			% 	iL = 5;
			% else
			% 	iL = 2 * (lower(cellType(1)) == 'm') + (lower(cellType(end)) == 'f')+1;
			% end

			FR = max(0, FR + randn(size(FR)) * sqrt(obj.activityParams.internalNoise) + obj.activityParams.internalNoise);
		end


		function FR = ExampleCellsActivitiesOnCondition(obj, cellType, ecc, sf, contrast, alignEvent, timeRange, isLinearFR, withInternalNoise)
			%% sf=0 or contrast=0 for grating absent condition
			% isLinearFR:	return linear activity for either noise or grating alone when true; false by default

			if(~exist('isLinearFR', 'var') || isempty(isLinearFR))
				isLinearFR = false;
			end
			if(~exist('withInternalNoise', 'var') || isempty(withInternalNoise))
				withInternalNoise = false;
			end

			if(isempty(obj.activityParams))
				fprintf('Please load activities with Encoder.LoadExampleCellsActivities() first!\n');
				return;
			end

			if(sf == 0)
				contrast = 0;
			end

			if(~exist('alignEvent', 'var') || isempty(alignEvent))
				alignEvent = 'saccadeOff';
				timeRange = obj.activityParams.timeline([1 end]);
			end

			if(~exist('timeRange', 'var') || isempty(timeRange))
				timeRange = obj.activityParams.timeline([1 end]);
			end


			iL = 2 * (lower(cellType(1)) == 'm') + (lower(cellType(end)) == 'f')+1;


			if(strcmpi(alignEvent, obj.activityParams.conditions(1).alignEvent))
				if(sf == 0 || contrast == 0)
					FR = obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == 0};
					if(~isLinearFR)
						FR = max(0, FR);
					end
					if(withInternalNoise)
						FR = obj.AddInternalNoise(FR);
					end
					% if(isLinearFR)
					% 	FR = obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == 0};
					% else
					% 	FR = max(0, obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == 0});
					% end
				else
					FR = contrast * obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == sf};
					if(~isLinearFR)
						FR = max(0, FR + obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == 0});
					end
					if(withInternalNoise)
						FR = obj.AddInternalNoise(FR);
					end
					
					% if(isLinearFR)
					% 	FR = contrast * obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == sf};
					% else
					% 	FR = max(0, obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == 0} + contrast * ...
					% 				obj.layers(iL).LFR{[obj.activityParams.conditions.eccentricity] == ecc & [obj.activityParams.conditions.sf] == sf});
					% end
				end
				[~, s] = min(abs(timeRange(1) - obj.activityParams.timeline));
				[~, e] = min(abs(timeRange(2) - obj.activityParams.timeline));
				FR = FR(:,s:e,:);
			else
				FR = [];		%%% need implementation
			end
		end


		function ShowLinearity(obj, dataFolder)
			%% Theoretically, for fixed RF parameters, the neuronal response before nonlinearity is linear to linear combinations of the contrast and target
			%  Here, we show this emperically

			if( nargin() < 2 || isempty(dataFolder) )
				dataFolder = '../../Data/';
			end
			trials = EmpiricalBox.LoadSingleData(fullfile(dataFolder, 'A014.mat'));
			iTrial = find([trials.eccentricity] == 4 & [trials.spatialFreq] == 2, 1, 'first');

			index = trials(iTrial).saccadeOff - round(0.150*trials(iTrial).sRate) : trials(iTrial).saccadeOff + round(500/1000*trials(iTrial).sRate);
			x  = trials(iTrial).x.position(index) / 60;
			y  = trials(iTrial).y.position(index) / 60;

			[noise, inputX, inputY] = obj.LoadNoise( fullfile(dataFolder, trials(iTrial).backgroundImage), trials(iTrial).pixelAngle/60 );
			grating = obj.GenerateGrating( trials(iTrial).spatialFreq, trials(iTrial).phase*pi, trials(iTrial).pixelAngle/60, trials(iTrial).eccentricity, trials(iTrial).gratingWidth );
			noise = noise * trials(iTrial).backgroundContrast;
            
			iL = 3;	% POn cell
			iCell = find( abs(obj.layers(iL).locations(:,1) - trials(iTrial).eccentricity) < 0.1 & abs(obj.layers(iL).locations(:,2)) < 0.1, 1, 'first' );

			figure('NumberTitle', 'off', 'name', 'Show Linearity Empirically', 'color', 'w');
			
			subplot(1,2,1);
			imshow( noise+grating, [], 'xdata', inputX([1 end]), 'ydata', inputY([1 end]) ); hold on;
			plot( x, y, 'b', 'lineWidth', 2 );
			rectangle( 'position', [ obj.layers(iL).locations(iCell, 1), obj.layers(iL).locations(iCell, 2), 2*obj.layers(iL).sRFParams(iCell).centerRadii, 2*obj.layers(iL).sRFParams(iCell).centerRadii ],...
					   'FaceColor', 'r', 'LineStyle', 'none', 'Curvature', [1 1] );
			set( gca, 'ydir', 'normal', 'visible', 'on', 'fontsize', 20, 'lineWidth', 2 );
            drawnow;

			%%
			avContrast = trials(iTrial).backgroundContrast;
			contrasts = 0.1:0.1:0.5;
			
			fprintf('Processing noise...\n');
			[~, sFR_c_noise, sFR_s_noise] = obj.SpatialModel.LinearResponse( noise, inputX, inputY, x, y, obj.layers(iL).sRFParams(iCell), obj.layers(iL).locations(iCell,1), obj.layers(iL).locations(iCell,2));
			LFR_noise = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(iCell), avContrast, trials(iTrial).sRate, sFR_c_noise, sFR_s_noise );
			subplot(1,2,2); hold on;
			t = (index-trials(iTrial).saccadeOff) / trials(iTrial).sRate * 1000;
			h(1) = plot( t, LFR_noise, 'g', 'LineWidth', 2, 'displayName', 'Noise Response' );
            drawnow;

			fprintf('Processing full contrast grating...\n');
			[~, sFR_c_grating, sFR_s_grating] = obj.SpatialModel.LinearResponse( grating, inputX, inputY, x, y, obj.layers(iL).sRFParams(iCell), obj.layers(iL).locations(iCell,1), obj.layers(iL).locations(iCell,2));
			LFR_grating = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(iCell), avContrast, trials(iTrial).sRate, sFR_c_grating, sFR_s_grating );

			for(k = size(contrasts,2) : -1 : 1)
				fprintf('Processing grating at contrast=%.2f...\n', contrasts(k));
				[~, sFR_c_direct(k,:), sFR_s_direct(k,:)] = obj.SpatialModel.LinearResponse( noise + grating*contrasts(k), inputX, inputY, x, y, obj.layers(iL).sRFParams(iCell), obj.layers(iL).locations(iCell,1), obj.layers(iL).locations(iCell,2));
				LFR_direct(k,:) = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(iCell), avContrast, trials(iTrial).sRate, sFR_c_direct(k,:), sFR_s_direct(k,:) );
				h(end+1) = plot( t, LFR_direct(k,:), '-', 'color', [0 0 1]*k/size(contrasts,2), 'lineWidth', 2, 'displayName', sprintf('Contrast=%.2f Direct', contrasts(k)) );
                drawnow;

				LFR_LC(k,:) = LFR_noise + LFR_grating * contrasts(k);
				h(end+1) = plot( t, LFR_LC(k,:), 'r--', 'color', [1 0 0]*k/size(contrasts,2), 'lineWidth', 2, 'displayName', sprintf('Contrast=%.2f Linear Combination', contrasts(k)) );
                drawnow;
			end

			legend( h, 'location', 'northeast' );
			set( gca, 'fontsize', 20, 'lineWidth', 2 );
			xlabel('Time (ms)')
			ylabel('Firing rate (spikes/s)');
		end


		function [LFR, time, conditions, trials, trialsIdx, idxExampleCells, idxAllCells, nExampleCells, nAllCells] = SimulateExampleCellsActivities(obj, idxConditions, dataFolder, sbj, alignEvent, stabilize, stimulus, saveFolder, nHours)
			%% Simulate activities of modeled cells at locations (0,0), (0,4), (0,8), (0,12)
			%	idxConditions:		indices of conditions to run, by default run all 9 conditions
			%   dataFolder:			folder containing experiment data and noise background
			%	alignEvent:			'saccadeOn', 'saccadeOff', 'flashOn'
			%   contrast:			contrast of grating
			%   stabilize:			'normal' (no stabilization), 'drift' (only stabilize drift), or 'full' (full stabilization)
			%	stimulus:			'annulus' (annulus grating) or 'uniform' (uniform grating across the visual field)
			%	nHours:				number of hours to run; Inf by default

			if( ~exist('idxConditions', 'var') || isempty(idxConditions) )
				idxConditions = 1:9;
			end
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data/';
			end
			if( ~exist('alignEvent', 'var') || isempty(alignEvent) )
				alignEvent = 'saccadeOff'; %'saccadeLand';%
			end
			if( ~exist('stabilize', 'var') || isempty(stabilize) )
				stabilize = 'normal';
			end
			if( ~exist('saveFolder', 'var') || isempty(saveFolder) )
				saveFolder = sprintf( 'Example Cells LFR' ); %sprintf( 'Example Cells LFR; contrast = %f', contrast );
			end
			if( saveFolder(end) == '/' || saveFolder(end) == '\' )
				saveFolder(end) = [];
			end
			if( ~exist('nHours', 'var') || isempty(nHours))
				nHours = Inf;
			end
			if( ~exist(fullfile(dataFolder,'Simulated Activities',sbj,saveFolder), 'dir') )
				mkdir( fullfile(dataFolder,'Simulated Activities',sbj,saveFolder) );
			end

			TimeLimit = nHours * 3600;		% ms

			t0 = tic;

			trials = EmpiricalBox.LoadSingleData(fullfile(dataFolder, 'Data', [sbj '.mat']));
			nTrials = 100;

			conditions = struct( ...
							'eccentricity',	{  0,   0,    0,   4,   4,   4,   8,   8,   8 }, ...
							'sf',			{  0,   2,   10,   0,   2,  10,   0,   2,  10 }, ...		% sf=0 means noise alone
							'duration',		{600}, ...
							'alignEvent',	{alignEvent} );
			
			[conditions.duration] = deal(600);
			[conditions.alignEvent] = deal(alignEvent);

			Eccs = unique([conditions.eccentricity]);

			if(strcmpi(stimulus, 'annulus'))
				[idxExampleCells, idxAllCells, nExampleCells, nAllCells] = obj.GetExampleCells(nan, [-pi pi]*0.02, dataFolder, Eccs, false);
			elseif(strcmpi(stimulus, 'uniform'))
				nCells = 500;
				[idxExampleCells, idxAllCells, nExampleCells, nAllCells] = obj.GetExampleCells(nCells, nan, dataFolder, Eccs, false);
			else
				fprintf('Argument stimulus must be ''annulus'' or ''uniform''!\n');
				return;
			end

			for( iCond = sort(idxConditions, 'descend') )	%size(conditions,2) : -1 : 1 )
				iEcc = find( conditions(iCond).eccentricity == Eccs );

				if(strcmpi(trials(1).backgroundImage(1:13), 'noise_nk(pos)'))
					noiseIdx = cellfun(@(x) str2num(x(21:end-4)), {trials.backgroundImage});
					trialsIdx{iCond} = find( noiseIdx <= 99 & abs( [trials.stimOff] - [trials.saccadeOff]./[trials.sRate]*1000 - (conditions(iCond).duration - 100) ) < 50, nTrials, 'first' );
				else
					trialsIdx{iCond} = find( abs( [trials.stimOff] - [trials.saccadeOff]./[trials.sRate]*1000 - (conditions(iCond).duration - 100) ) < 50, nTrials, 'first' );
				end

				idx = trialsIdx{iCond};
				tMax = round(max( [trials(idx).saccadeOff] + round(conditions(iCond).duration/1000*[trials(idx).sRate]) - [trials(idx).(alignEvent)] ));	% in samples
				tMin = round(min( [trials(idx).saccadeOn] - round(0.150*[trials(idx).sRate]) - [trials(idx).(alignEvent)] ));				% in samples
				for( iL = 4 : -1 : 1 )
					% sFR{iCond,iL} = zeros( nCellsUsed{iL,iEcc}, tMax-tMin+1, size(idx,2) );		% 1st dim: neurons;		2nd dim: time;		3rd dim: trials;
					sFR{iL} = zeros( nExampleCells{iL,iEcc}, tMax-tMin+1, size(idx,2), 'single' );		% 1st dim: neurons;		2nd dim: time;		3rd dim: trials;
				end
				sFR_c = sFR;	%sFR_c{iCond,iL} = sFR{iCond,iL};
				sFR_s = sFR;	%sFR_s{iCond,iL} = sFR{iCond,iL};
				LFR(iCond,:) = sFR;	%LFR{iCond,iL} = sFR{iCond,iL};

				kMax = size(idx,2);
				if(exist(fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'file'))
					load(fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ));
					kMax = k - 1;
					LFR(iCond,:) = lfr;
				end
				for( k = kMax : -1 : 1 )
					% tic;
					index = tMin + trials(idx(k)).(alignEvent) : min( size(trials(idx(k)).x.position,2), tMax + trials(idx(k)).(alignEvent) );
					x  = trials(idx(k)).x.position(index) / 60;
					y  = trials(idx(k)).y.position(index) / 60;
                    
					% before saccade
					eyeIdx{1} = 1 : trials(idx(k)).saccadeOn - trials(idx(k)).(alignEvent) - tMin;
					s1 = size(eyeIdx{1},2);

					% during saccade
					eyeIdx{2} = eyeIdx{1}(end) + ( 1 : trials(idx(k)).saccadeOff - trials(idx(k)).saccadeOn + 1 );
					s2 = size(eyeIdx{2},2);

					% after saccade
					eyeIdx{3} = eyeIdx{2}(end)+1 : size(x,2);
					s3 = size(eyeIdx{3},2);

					if( strcmpi( stabilize, 'drift' ) )
						x(eyeIdx{1}) = x(eyeIdx{1}(end));
						y(eyeIdx{1}) = y(eyeIdx{1}(end));
						x(eyeIdx{3}) = x(eyeIdx{3}(1));
						y(eyeIdx{3}) = y(eyeIdx{3}(1));
					elseif( strcmpi( stabilize, 'saccade' ) )
						% only stabilize saccade period
						if(false)
	                        eyeIdx{2} = [eyeIdx{1}(end-24:end), eyeIdx{2}, eyeIdx{3}(1:25)];
	                        eyeIdx{1} = eyeIdx{1}(1:end-25);
	                        eyeIdx{3} = eyeIdx{3}(26:end);
							x(eyeIdx{1}) = x(eyeIdx{3}(1)) + x(eyeIdx{1}) - x(eyeIdx{1}(end));
							x(eyeIdx{2}) = x(eyeIdx{3}(1));
	                        y(eyeIdx{1}) = y(eyeIdx{3}(1)) + y(eyeIdx{1}) - y(eyeIdx{1}(end));
							y(eyeIdx{2}) = y(eyeIdx{3}(1));

						% stabilize both saccade and pre-saccade drift
						else
							eyeIdx{2} = [eyeIdx{1}(end-24:end), eyeIdx{2}, eyeIdx{3}(1:25)];
	                        eyeIdx{1} = eyeIdx{1}(1:end-25);
	                        eyeIdx{3} = eyeIdx{3}(26:end);
							x(eyeIdx{1}) = x(eyeIdx{3}(1));
							x(eyeIdx{2}) = x(eyeIdx{3}(1));
	                        y(eyeIdx{1}) = y(eyeIdx{3}(1));
							y(eyeIdx{2}) = y(eyeIdx{3}(1));
						end
						

					elseif( strcmpi( stabilize, 'full' ) )
						x(:) = x(eyeIdx{3}(1));
						y(:) = y(eyeIdx{3}(1));
					end

					% hold on;
					% plot(x, 'b', 'tag', num2str(k));
					% plot(y, 'r', 'tag', num2str(k));
					% if(k == 1)
					% 	return;
					% else
					% 	continue;
					% end

					if(conditions(iCond).sf == 0)
	                    [stimulus, inputX, inputY] = obj.LoadNoise( fullfile(dataFolder, trials(idx(k)).backgroundImage), trials(idx(k)).pixelAngle/60 );
	                    stimulus = stimulus * 0.5;		% noise at a contrast of 0.5
	                else
	                	% full contrast grating
	                	if(strcmpi(stimulus, 'annulus'))	% annulus grating
							[stimulus, inputX, inputY] = obj.GenerateGrating( conditions(iCond).sf, trials(idx(k)).phase, trials(idx(k)).pixelAngle/60, conditions(iCond).eccentricity, trials(idx(k)).gratingWidth );
						elseif(strcmpi(stimulus, 'uniform'))	% uniform grating across the whole visual field
							rndPhase = str2double(trials(mod(idx(k),end)+1).backgroundImage(find(trials(mod(idx(k),end)+1).backgroundImage == '_')+1 : end-4));	% use the backgroundImage index of the trial after idx(k) as the random value for phase
							rndOri = str2double(trials(mod(idx(k)+1,end)+1).backgroundImage(find(trials(mod(idx(k)+1,end)+1).backgroundImage == '_')+1 : end-4));	% use the backgroundImage index of the trial after idx(k) as the random value for orientation
							[stimulus, inputX, inputY] = obj.GenerateGrating( conditions(iCond).sf, mod(rndPhase,100)/100*2*pi, trials(idx(k)).pixelAngle/60, -1, mod(rndOri,100)/100*360 );
						end
					end
                    
					avContrast = 0.5;

					for( iL = 1:4 )
						fprintf('iCond=%d, Ecc=%d, SF=%d, iTrials=%d/%d, iL=%d, ...', iCond, conditions(iCond).eccentricity, conditions(iCond).sf, k, size(idx,2), iL);
						t1 = tic;
						for( m = 1 : 3 )
							xIdx = min(x(eyeIdx{m})) + min(obj.layers(iL).locations(idxExampleCells{iL,iEcc},1)) - 4 <= inputX & inputX <= max(x(eyeIdx{m})) + max(obj.layers(iL).locations(idxExampleCells{iL,iEcc},1)) + 4; %720 : 1460;
		                    yIdx = min(y(eyeIdx{m})) + min(obj.layers(iL).locations(idxExampleCells{iL,iEcc},2)) - 4 <= inputY & inputY <= max(y(eyeIdx{m})) + max(obj.layers(iL).locations(idxExampleCells{iL,iEcc},2)) + 4; %300 : 780;
	                    
							[sFR{iL}(:,eyeIdx{m},k), sFR_c{iL}(:,eyeIdx{m},k), sFR_s{iL}(:,eyeIdx{m},k)] = obj.SpatialModel.LinearResponse( stimulus(yIdx,xIdx), inputX(xIdx), inputY(yIdx), x(eyeIdx{m}), y(eyeIdx{m}), obj.layers(iL).sRFParams(idxExampleCells{iL,iEcc}), obj.layers(iL).locations(idxExampleCells{iL,iEcc},1), obj.layers(iL).locations(idxExampleCells{iL,iEcc},2));
						end
						if( lower(obj.layers(iL).name(1)) == 'm' )
							LFR{iCond,iL}(:,:,k) = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(idxExampleCells{iL,iEcc}), avContrast, trials(idx(k)).sRate, sFR{iL}(:,:,k) );
						else
							LFR{iCond,iL}(:,:,k) = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(idxExampleCells{iL,iEcc}), avContrast, trials(idx(k)).sRate, sFR_c{iL}(:,:,k), sFR_s{iL}(:,:,k) );
						end
						fprintf(' | t=%f\n', toc(t1));
					end

					if(toc(t0) > TimeLimit)
						fprintf('Times up, saving data...\n');
						if(isempty(idx))
							time{iCond} = [];
						else
							time{iCond} = (tMin:tMax) / trials(idx(1)).sRate * 1000;
						end

						lfr = LFR(iCond,:);
						save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'sbj', 'iCond', 'lfr', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', 'k' );
						fprintf('Data saved!\n');
						return;
					
					elseif(TimeLimit ~= Inf)
						t_ = TimeLimit - toc(t0);
						fprintf('Count down: %02d:%02d:%02d\n', floor(t_/3600), floor(mod(t_,3600)/60), mod(round(t_),60));
					end
				end
				if(isempty(idx))
					time{iCond} = [];
				else
					time{iCond} = (tMin:tMax) / trials(idx(1)).sRate * 1000;
				end

				lfr = LFR(iCond,:);
				save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'sbj', 'iCond', 'lfr', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', 'k' );
			end
            
            % save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, [saveFolder, '.mat'] ), 'LFR', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', '-v7.3' );
		end


		function [LFR, time, conditions, trials, trialsIdx, idxExampleCells, idxAllCells, nExampleCells, nAllCells] = SimulateExampleCellsActivities_SacDB(obj, idxConditions, dataFolder, alignEvent, stabilize, saveFolder, nHours)
			%% Simulate activities of modeled cells at a series of eccentricities (0,0:2:14), given eye traces from the saccade database (SacDB)
			%	idxConditions:		indices of conditions to run, by default run all 9 conditions
			%   dataFolder:			folder containing experiment data and noise background
			%	alignEvent:			'saccadeOn', 'saccadeOff', 'flashOn'
			%   contrast:			contrast of grating
			%   stabilize:			'normal' (no stabilization), 'drift' (only stabilize drift), or 'full' (full stabilization)
			%	nHours:				number of hours to run; Inf by default

			if( ~exist('idxConditions', 'var') || isempty(idxConditions) )
				idxConditions = 1:9;
			end
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data/';
			end
			if( ~exist('alignEvent', 'var') || isempty(alignEvent) )
				alignEvent = 'saccadeOff'; %'saccadeLand';%
			end
			if( ~exist('stabilize', 'var') || isempty(stabilize) )
				stabilize = 'normal';
			end
			if( ~exist('saveFolder', 'var') || isempty(saveFolder) )
				saveFolder = sprintf( 'Example Cells LFR' ); %sprintf( 'Example Cells LFR; contrast = %f', contrast );
			end
			if( saveFolder(end) == '/' || saveFolder(end) == '\' )
				saveFolder(end) = [];
			end
			if( ~exist('nHours', 'var') || isempty(nHours))
				nHours = Inf;
			end
			TimeLimit = nHours * 3600;	% ms

			t0 = tic;

			sbj = 'SacDB';
			if( ~exist(fullfile(dataFolder,'Simulated Activities',sbj,saveFolder), 'dir') )
				mkdir( fullfile(dataFolder,'Simulated Activities',sbj,saveFolder) );
			end

			trials = EmpiricalBox.LoadSacDB();
			nTrials = size(trials,2);

			conditions = struct( ...
							'eccentricity',	num2cell(reshape(repmat(0:2:14, 3, 1), 1, [])), ... %{  0,   0,    0,   4,   4,   4,   8,   8,   8 }, ...
							'sf',			num2cell(repmat([0 2 10], 1, size(0:2:14, 2))), ... %{  0,   2,   10,   0,   2,  10,   0,   2,  10 }, ...		% sf=0 means noise alone
							'duration',		{600}, ...
							'alignEvent',	{alignEvent} );
			
			[conditions.duration] = deal(600);
			[conditions.alignEvent] = deal(alignEvent);

			Eccs = unique([conditions.eccentricity]);

			stimulusType = 'uniform';
			if(strcmpi(stimulusType, 'annulus'))
				[idxExampleCells, idxAllCells, nExampleCells, nAllCells] = obj.GetExampleCells(nan, [-pi pi]*0.02, dataFolder, Eccs, false);
			elseif(strcmpi(stimulusType, 'uniform'))
				nCells = 500;
				[idxExampleCells, idxAllCells, nExampleCells, nAllCells] = obj.GetExampleCells(nCells, nan, dataFolder, Eccs, false);
			else
				fprintf('Argument stimulus must be ''annulus'' or ''uniform''!\n');
				return;
			end

			for( iCond = sort(idxConditions, 'descend') )
				iEcc = find( conditions(iCond).eccentricity == Eccs );
				trialsIdx{iCond} = 1 : nTrials;

				idx = trialsIdx{iCond};
				tMax = round(max( [trials(idx).saccadeOff] + round(conditions(iCond).duration/1000*[trials(idx).sRate]) - [trials(idx).(alignEvent)] ));	% in samples
				tMin = round(min( [trials(idx).saccadeOn] - round(0.150*[trials(idx).sRate]) - [trials(idx).(alignEvent)] ));				% in samples
				for( iL = 4 : -1 : 1 )
					sFR{iL} = zeros( nExampleCells{iL,iEcc}, tMax-tMin+1, size(idx,2), 'single' );		% 1st dim: neurons;		2nd dim: time;		3rd dim: trials;
				end
				sFR_c = sFR;
				sFR_s = sFR;
				LFR(iCond,:) = sFR;

				kMax = size(idx,2);
				if(exist(fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'file'))
					load(fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ));
					kMax = k - 1;
					LFR(iCond,:) = lfr;
				end
				for( k = kMax : -1 : 1 )
					% tic;
					index = tMin + trials(idx(k)).(alignEvent) : min( size(trials(idx(k)).x.position,2), tMax + trials(idx(k)).(alignEvent) );
					x  = trials(idx(k)).x.position(index) / 60;
					y  = trials(idx(k)).y.position(index) / 60;
                    
					% before saccade
					eyeIdx{1} = 1 : trials(idx(k)).saccadeOn - trials(idx(k)).(alignEvent) - tMin;
					s1 = size(eyeIdx{1},2);

					% during saccade
					eyeIdx{2} = eyeIdx{1}(end) + ( 1 : trials(idx(k)).saccadeOff - trials(idx(k)).saccadeOn + 1 );
					s2 = size(eyeIdx{2},2);

					% after saccade
					eyeIdx{3} = eyeIdx{2}(end)+1 : size(x,2);
					s3 = size(eyeIdx{3},2);

					if( strcmpi( stabilize, 'drift' ) )
						x(eyeIdx{1}) = x(eyeIdx{1}(end));
						y(eyeIdx{1}) = y(eyeIdx{1}(end));
						x(eyeIdx{3}) = x(eyeIdx{3}(1));
						y(eyeIdx{3}) = y(eyeIdx{3}(1));

					elseif( strcmpi( stabilize, 'saccade' ) )
						% only stabilize saccade period
						if(false)
	                        eyeIdx{2} = [eyeIdx{1}(end-24:end), eyeIdx{2}, eyeIdx{3}(1:25)];
	                        eyeIdx{1} = eyeIdx{1}(1:end-25);
	                        eyeIdx{3} = eyeIdx{3}(26:end);
							x(eyeIdx{1}) = x(eyeIdx{3}(1)) + x(eyeIdx{1}) - x(eyeIdx{1}(end));
							x(eyeIdx{2}) = x(eyeIdx{3}(1));
	                        y(eyeIdx{1}) = y(eyeIdx{3}(1)) + y(eyeIdx{1}) - y(eyeIdx{1}(end));
							y(eyeIdx{2}) = y(eyeIdx{3}(1));

						% stabilize both saccade and pre-saccade drift
						else
							eyeIdx{2} = [eyeIdx{1}(end-24:end), eyeIdx{2}, eyeIdx{3}(1:25)];
	                        eyeIdx{1} = eyeIdx{1}(1:end-25);
	                        eyeIdx{3} = eyeIdx{3}(26:end);
							x(eyeIdx{1}) = x(eyeIdx{3}(1));
							x(eyeIdx{2}) = x(eyeIdx{3}(1));
	                        y(eyeIdx{1}) = y(eyeIdx{3}(1));
							y(eyeIdx{2}) = y(eyeIdx{3}(1));
						end
						
					elseif( strcmpi( stabilize, 'full' ) )
						x(:) = x(eyeIdx{3}(1));
						y(:) = y(eyeIdx{3}(1));
					end

					% hold on;
					% plot(eyeIdx{1}, x(eyeIdx{1}), 'b', 'tag', num2str(k));
					% plot(eyeIdx{2}, x(eyeIdx{2}), 'c', 'tag', num2str(k));
					% plot(eyeIdx{3}, x(eyeIdx{3}), 'b', 'tag', num2str(k));
					% plot(eyeIdx{1}, y(eyeIdx{1}), 'r', 'tag', num2str(k));
					% plot(eyeIdx{2}, y(eyeIdx{2}), 'm', 'tag', num2str(k));
					% plot(eyeIdx{3}, y(eyeIdx{3}), 'r', 'tag', num2str(k));
					% if(k == 1)
					% 	return;
					% else
					% 	continue;
					% end

					if(conditions(iCond).sf == 0)
	                    [stimulus, inputX, inputY] = obj.LoadNoise( fullfile(dataFolder, trials(idx(k)).backgroundImage), trials(idx(k)).pixelAngle/60 );
	                    stimulus = stimulus * 0.5;		% noise at a contrast of 0.5
	                else
	                	% full contrast grating
	                	if(strcmpi(stimulusType, 'annulus'))	% annulus grating
							[stimulus, inputX, inputY] = obj.GenerateGrating( conditions(iCond).sf, trials(idx(k)).phase, trials(idx(k)).pixelAngle/60, conditions(iCond).eccentricity, trials(idx(k)).gratingWidth );
						elseif(strcmpi(stimulusType, 'uniform'))	% uniform grating across the whole visual field
							rndPhase = str2double(trials(mod(idx(k),end)+1).backgroundImage(find(trials(mod(idx(k),end)+1).backgroundImage == '_')+1 : end-4));	% use the backgroundImage index of the trial after idx(k) as the random value for phase
							rndOri = str2double(trials(mod(idx(k)+1,end)+1).backgroundImage(find(trials(mod(idx(k)+1,end)+1).backgroundImage == '_')+1 : end-4));	% use the backgroundImage index of the trial after idx(k) as the random value for orientation
							[stimulus, inputX, inputY] = obj.GenerateGrating( conditions(iCond).sf, mod(rndPhase,100)/100*2*pi, trials(idx(k)).pixelAngle/60, -1, mod(rndOri,100)/100*360 );
						end
					end
                    
					avContrast = 0.5;

					for( iL = 1:4 )
						fprintf('iCond=%d, Ecc=%d, SF=%d, iTrials=%d/%d, iL=%d, ...', iCond, conditions(iCond).eccentricity, conditions(iCond).sf, k, size(idx,2), iL);
						t1 = tic;
						for( m = 1 : 3 )
							d = max([obj.layers(iL).sRFParams(idxExampleCells{iL,iEcc}).surroundRadii]) * 5;		% extra space beyond given cells
							cellLocs = obj.layers(iL).locations(idxExampleCells{iL,iEcc}, :) - mean(obj.layers(iL).locations(idxExampleCells{iL,iEcc}, :), 1);	% bring the cells to the center
							xIdx = min(x(eyeIdx{m})) + min(cellLocs(:,1)) - d <= inputX & inputX <= max(x(eyeIdx{m})) + max(cellLocs(:,1)) + d;
		                    yIdx = min(y(eyeIdx{m})) + min(cellLocs(:,2)) - d <= inputY & inputY <= max(y(eyeIdx{m})) + max(cellLocs(:,2)) + d;
	                    
							[sFR{iL}(:,eyeIdx{m},k), sFR_c{iL}(:,eyeIdx{m},k), sFR_s{iL}(:,eyeIdx{m},k)] = obj.SpatialModel.LinearResponse( stimulus(yIdx,xIdx), inputX(xIdx), inputY(yIdx), x(eyeIdx{m}), y(eyeIdx{m}), obj.layers(iL).sRFParams(idxExampleCells{iL,iEcc}), cellLocs(:,1), cellLocs(:,2));
						end
						if( lower(obj.layers(iL).name(1)) == 'm' )
							LFR{iCond,iL}(:,:,k) = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(idxExampleCells{iL,iEcc}), avContrast, trials(idx(k)).sRate, sFR{iL}(:,:,k) );
						else
							LFR{iCond,iL}(:,:,k) = obj.TemporalModel.LinearResponse( obj.layers(iL).name, obj.layers(iL).tRFParams(idxExampleCells{iL,iEcc}), avContrast, trials(idx(k)).sRate, sFR_c{iL}(:,:,k), sFR_s{iL}(:,:,k) );
						end
						fprintf(' | t=%f\n', toc(t1));
					end

					if(toc(t0) >= TimeLimit)
						fprintf('Times up, saving data...\n');
						if(isempty(idx))
							time{iCond} = [];
						else
							time{iCond} = (tMin:tMax) / trials(idx(1)).sRate * 1000;
						end

						lfr = LFR(iCond,:);
						save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'sbj', 'iCond', 'lfr', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', 'k' );
						fprintf('Data saved!\n');
						t0 = tic;

						% return;
					elseif(TimeLimit ~= Inf)
						t_ = TimeLimit - toc(t0);
						fprintf('Count down: %02d:%02d:%02d\n', floor(t_/3600), floor(mod(t_,3600)/60), mod(round(t_),60));
					end
					
				end
				if(isempty(idx))
					time{iCond} = [];
				else
					time{iCond} = (tMin:tMax) / trials(idx(1)).sRate * 1000;
				end

				lfr = LFR(iCond,:);
				save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, sprintf('%s-%02d.mat', 'Condition', iCond) ), 'sbj', 'iCond', 'lfr', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', 'k' );
				fprintf('Finished: iCond = %d!\n', iCond);
			end
            
            % save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, [saveFolder, '.mat'] ), 'LFR', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', '-v7.3' );
		end


		function GatherSimulatedExampleCellsActivities(obj, dataFolder, sbj, saveFolder)
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data/';
			end

			files = dir(fullfile(dataFolder, 'Simulated Activities', sbj, saveFolder, 'condition-*.mat'));

			for(iCond = size(files,1) : -1 : 1)
				fprintf('Processing %s-%02d.mat ...\n', saveFolder, iCond);
				data = load(fullfile(files(iCond).folder, files(iCond).name));
				if(iCond ~= data.iCond)
					warning('iCond not consistent!!!\n');
				end
				LFR(iCond,:) = data.lfr;
				time(iCond) = data.time(iCond);
				trialsIdx(iCond) = data.trialsIdx(iCond);
			end
			conditions = data.conditions;
			trials = data.trials;
			idxExampleCells = data.idxExampleCells;
			idxAllCells = data.idxAllCells;
			nExampleCells = data.nExampleCells;
			nAllCells = data.nAllCells;

			fprintf('Saving %s.mat ...\n', saveFolder);
			save( fullfile( dataFolder, 'Simulated Activities', sbj, saveFolder, ['All Conditions', '.mat'] ), 'LFR', 'time', 'conditions', 'trials', 'trialsIdx', 'idxExampleCells', 'idxAllCells', 'nExampleCells', 'nAllCells', '-v7.3' );
		end


		function [idxExampleCells, idxAllCells, nExampleCells, nAllCells] = GetExampleCells(obj, nCells, angularRange, dataFolder, eccs, isPlot)
			%%
			% nCells:		select nCells at the temporal meridian for each eccentricity; not used if nCells == nan
			% angularRange:	select an annulus and use a sector of the given angularRange (rad) for each eccentricity; not used if angularRange == nan

			if(~exist('radius', 'var') || isempty(radius))
				radius = 0.5;		% degree
			end
			if(~exist('angularRange', 'var') || isempty(angularRange))
				angularRange = -1;%[-pi pi] * 0.02;	% by default, a sector covering 2% of the area at the temporal field
			end
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data/';
            end
            if(~exist('eccs', 'var') || isempty(eccs))
            	eccs = [0 4 8];
            end
			if(~exist('isPlot', 'var') || isempty(isPlot))
				isPlot = true;
			end

			if(~isnan(nCells))	% select fixed number of cells (nCells) at each eccentricity
				for( iEcc = size(eccs,2) : -1 : 1 )
					d2 = sum( (cat(1, obj.layers.locations) - [eccs(iEcc), 0]).^2, 2 );
					[~,idx] = sort(d2);
					idx = idx(1:nCells);
					tmpN = cumsum([0, cellfun(@(x) size(x,1), {obj.layers.locations})]);
					for( iL = size(obj.layers,2) : -1 : 1 )
						idxAllCells{iL,iEcc} = idx( tmpN(iL) < idx & idx <= tmpN(iL+1) ) - tmpN(iL);
						nAllCells{iL,iEcc} = length(idxAllCells{iL,iEcc});

						idxExampleCells{iL,iEcc} = idxAllCells{iL,iEcc};
						nExampleCells{iL,iEcc} = length(idxExampleCells{iL,iEcc});
					end
				end

			elseif(all(~isnan(angularRange)))
				if(~isempty(obj.activityParams))
					trials = obj.activityParams.trials;
				else
		            trials = EmpiricalBox.LoadSingleData(fullfile(dataFolder, 'Data/A014.mat'));
		        end
	            iTrial = find([trials.eccentricity] == 4 & [trials.spatialFreq] == 2, 1, 'first');

				for( iL = size(obj.layers,2) : -1 : 1 )
					angles = cart2pol(obj.layers(iL).locations(:,1), obj.layers(iL).locations(:,2));
					index = angularRange(1) <= angles & angles < angularRange(2);
					
					for( iEcc = size(eccs,2) : -1 : 1 )
						d2 = sum( obj.layers(iL).locations.^2, 2 );
						if( eccs(iEcc) == 0 )
							idx = d2 <= trials(1).gratingWidth^2;
						else
							w = trials(1).gratingWidth/2;
							idx = (eccs(iEcc)-w)^2 <= d2 & d2 <= (eccs(iEcc)+w)^2;
						end

						idxAllCells{iL,iEcc} = find(idx);
						nAllCells{iL,iEcc} = length(idxAllCells{iL,iEcc});
						
						idxExampleCells{iL,iEcc} = find( idx & index );
						nExampleCells{iL,iEcc} = length(idxExampleCells{iL,iEcc});
					end
				end

			else
				fprintf('Must specify nCells or angularRange!\n');
				return;
			end


			if(isPlot)
				if(~isnan(nCells))
					[noise, inputX, inputY] = obj.LoadNoise( fullfile(dataFolder, 'noise/noise_1.bin'), 1/60 );
					grating = obj.GenerateGrating( 2, 0, 1/60, -1, 45 );	% uniform grating across visual field
				elseif(all(~isnan(angularRange)))
					[noise, inputX, inputY] = obj.LoadNoise( fullfile(dataFolder, trials(iTrial).backgroundImage), trials(iTrial).pixelAngle/60 );
					grating0 = obj.GenerateGrating( trials(iTrial).spatialFreq, trials(iTrial).phase, trials(iTrial).pixelAngle/60, 0, trials(iTrial).gratingWidth );
					grating4 = obj.GenerateGrating( trials(iTrial).spatialFreq, trials(iTrial).phase, trials(iTrial).pixelAngle/60, 4, trials(iTrial).gratingWidth );
					grating8 = obj.GenerateGrating( trials(iTrial).spatialFreq, trials(iTrial).phase, trials(iTrial).pixelAngle/60, 8, trials(iTrial).gratingWidth );
					grating = grating0 + grating4 + grating8;
				end
				
				figure('NumberTitle', 'off', 'name', 'Example Cells', 'color', 'w');
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);
				colors = {[1 0 0], [0 0 1], [1 0 1], [0 1 1]};
                LimX = [ min(cellfun(@(loc,k) min(loc(k,1)), {obj.layers.locations}, {cat(1,idxAllCells{1,:}), cat(1,idxAllCells{2,:}), cat(1,idxAllCells{3,:}), cat(1,idxAllCells{4,:})})),...
                         max(cellfun(@(loc,k) max(loc(k,1)), {obj.layers.locations}, {cat(1,idxAllCells{1,:}), cat(1,idxAllCells{2,:}), cat(1,idxAllCells{3,:}), cat(1,idxAllCells{4,:})}))];
                LimY = [ min(cellfun(@(loc,k) min(loc(k,2)), {obj.layers.locations}, {cat(1,idxAllCells{1,:}), cat(1,idxAllCells{2,:}), cat(1,idxAllCells{3,:}), cat(1,idxAllCells{4,:})})),...
                         max(cellfun(@(loc,k) max(loc(k,2)), {obj.layers.locations}, {cat(1,idxAllCells{1,:}), cat(1,idxAllCells{2,:}), cat(1,idxAllCells{3,:}), cat(1,idxAllCells{4,:})}))];
				for(iL = 1 : 4)
					subplot(2,2,iL)
					imshow( (noise+grating)*0.25 + 0.5, 'xdata', inputX([1 end]), 'ydata', inputY([1 end]) ); hold on;
					titleTxt = [obj.layers(iL).name ' | nCells='];
					
					for(iEcc = 1 : size(eccs,2))
						MarkerSize = norm(diff(obj.layers(iL).locations(idxExampleCells{iL,iEcc}(1:2), :),1)) * 138;
						plot( obj.layers(iL).locations(idxAllCells{iL,iEcc}, 1), obj.layers(iL).locations(idxAllCells{iL,iEcc}, 2), '.', 'MarkerSize', MarkerSize, 'color', colors{iL} );
						if(all(~isnan(angularRange)))
							plot( obj.layers(iL).locations(idxExampleCells{iL,iEcc}, 1), obj.layers(iL).locations(idxExampleCells{iL,iEcc}, 2), '.', 'MarkerSize', MarkerSize, 'color', colors{iL}/2 );
						end
						titleTxt = [titleTxt num2str(nAllCells{iL,iEcc}) ', '];
					end
					title(titleTxt(1:end-2));
					set( gca, 'xlim', LimX+[-0.3 0.3], 'ylim', LimY+[-0.3 0.3], 'ydir', 'normal', 'visible', 'on', 'fontsize', 18, 'lineWidth', 2 );
					if(iL == 1 || iL == 3)
						ylabel('Vertical position (deg)');
					end
					if(iL == 3 || iL == 4)
						xlabel('Horizontal position (deg)');
					end
				end

				%% display Properties 	%%%%%%%%%%%%%%%%%%%%%%%
				figure( 'NumberTitle', 'off', 'name', 'Eye Movements & Cell Properties', 'color', 'w' );
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);

				if(exist('trials', 'var'))
					% saccadeOn - flashOn, saccadeOff - flashOn
					subplot(2, 3, 6); hold on;
					centers = -100:5:100;
					data = hist( ([trials.saccadeOn] - [trials.saccadeOff]) ./ [trials.sRate]*1000, centers );
					bar( centers, data, 0.9, 'b', 'LineStyle', 'none', 'displayName', 'sacOn - sacOff' );
					% data = hist( ([trials.saccadeOff] - [trials.flashOn]) ./ [trials.sRate]*1000, centers );
					% bar( centers, data, 0.9, 'r', 'LineStyle', 'none', 'displayName', 'sacOff - flashOn' );
					data = hist( ([trials.saccadeLand] - [trials.saccadeOff]) ./ [trials.sRate]*1000, centers );
					bar( centers, data, 0.9, 'm', 'LineStyle', 'none', 'displayName', 'sacLand - sacOff' );
					set( legend, 'location', 'northwest' );
					xlabel('Time aligned to saccadeOff (ms)');
					ylabel('Frequency');
					set( gca, 'lineWidth', 2, 'fontsize', 16 );

					% eye traces
					% subplot(3, 2, 2); hold on;
					% for( k = size(idx,2) : -1 : 1 )
					% 	x = trials(idx(k)).x.position( -100+trials(idx(k)).saccadeLand : min(end, 100+trials(idx(k)).saccadeLand) );
					% 	eyeX( k, 1:size(x,2) ) = x;
					% end
					% m = mean( eyeX, 1 );
					% sd = std( eyeX, [], 1 );
					% plot( -100:100, m, 'b', 'lineWidth', 2 );
					% fill( [-100:100, 100:-1:-100], [m-sd, m(end:-1:1)+sd(end:-1:1)], 'b', 'LineStyle', 'none', 'FaceAlpha', 0.5 );
					% plot( [0 0], get(gca,'ylim'), 'k--', 'lineWidth', 2 );
					% xlabel('Time aligned to saccadeLand');
					% ylabel('Horizontal eye (mean+-std) (arcmin)');
					% set( gca, 'lineWidth', 2, 'fontsize', 16 );
				end

				% cell spatial sensitivity function
				colors = {[1 0 0], [0 0 1], [1 0 1], [0 1 1]};
				sf = 0.1:0.1:40;
				for(iL = 1 : 4)
					subplot(2, 3, iL+(iL>2)); hold on; h = [];
					for(iEcc = 1:size(eccs,2))
						nCells = size(idxExampleCells{iL,iEcc},1);
						idx = idxExampleCells{iL,iEcc};
						m = mean( abs( obj.SpatialModel.SpatialSensitivity( obj.layers(iL).sRFParams(idx), sf ) ), 1 );
						sem = std( abs( obj.SpatialModel.SpatialSensitivity( obj.layers(iL).sRFParams(idx), sf ) ), [], 1 );% / sqrt(nCells);
						fill( [sf, sf(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], 'k', 'FaceColor', colors{iL}, 'LineStyle', 'none', 'FaceAlpha', 0.5 );
						h(iEcc) = plot( sf, m, 'color', colors{iL}*(size(eccs,2)-iEcc+1)/size(eccs,2), 'lineWidth', 2, 'displayName', sprintf('Ecc = %d', eccs(iEcc)) );
					end
					set( gca, 'ylim', 10.^([-5,1]), 'xscale', 'log', 'yscale', 'log', 'lineWidth', 2, 'fontsize', 16 );
					plot( [2 2], get(gca,'ylim'), 'k--', 'lineWidth', 2 );
					plot( [10 10], get(gca,'ylim'), 'k--', 'lineWidth', 2 );
					set(legend(h), 'location', 'southwest');
					xlabel('Spatial frequency (CPD)');
					if(iL==1), ylabel('Sensitivity'); end
					title(obj.layers(iL).name);
				end

				% cell temporal sensitivity function
				tf = 0.1:0.1:60;
				for(iEcc = 1)%:size(eccs,2))
					% subplot(2, size(eccs,2), size(eccs,2)*2+iEcc); hold on; h = [];
					subplot(2, 3, 3); hold on; h = [];
					for(iL = 1 : 4)
						nCells = size(idxExampleCells{iL,iEcc},1);
						idx = idxExampleCells{iL,iEcc};
						if( iL <= 2 )
							[C, S] = obj.TemporalModel.TemporalSensitivity( obj.layers(iL).name, obj.layers(iL).tRFParams(idx), tf );
							m = mean(C,1);
							sem = std(C, [], 1);% / sqrt(nCells);
							h(end+1) = plot( tf, m, 'color', colors{iL}, 'lineWidth', 2, 'displayName', [obj.layers(iL).name ' Center'] );
							fill( [tf, tf(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], 'k', 'FaceColor', colors{iL}, 'LineStyle', 'none', 'FaceAlpha', 0.5 );

							m = mean(S,1);
							sem = std(S, [], 1);% / sqrt(nCells);
							h(end+1) = plot( tf, m, 'color', colors{iL}/2, 'lineWidth', 2, 'displayName', [obj.layers(iL).name ' Surround'] );
							fill( [tf, tf(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], 'k', 'FaceColor', colors{iL}, 'LineStyle', 'none', 'FaceAlpha', 0.5 );
						else
							S = obj.TemporalModel.TemporalSensitivity( obj.layers(iL).name, obj.layers(iL).tRFParams(idx), tf, 0.5 );
							m = mean(S,1);
							sem = std(S, [], 1);% / sqrt(nCells);
							h(end+1) = plot( tf, m, 'color', colors{iL}, 'lineWidth', 2, 'displayName', obj.layers(iL).name );
							fill( [tf, tf(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], 'k', 'FaceColor', colors{iL}, 'LineStyle', 'none', 'FaceAlpha', 0.5 );
						end
					end
					% if(iEcc==nRows), legend(h); end
					legend(h);
					xlabel('Temporal frequency (Hz)');
					ylabel('Sensitivity');
					% if(iEcc == 1), ylabel('Sensitivity'); end
					set( gca, 'xscale', 'log', 'yscale', 'log', 'lineWidth', 2, 'fontsize', 16 );
				end


				%% Spatio-temporal activity map of single trials
				if(~isempty(obj.activityParams))
					figure('color', 'w');
					iL = 1;
					t = obj.activityParams.timeline;
					for(iCond = 2:-1:1)
						fr{iCond} = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, 0, (iCond-1)*2, 0.5, 'saccadeOff', t([1 end]));
						for(iTrial = 1 : 4)
							subplot(2,4,iTrial+(iCond-1)*4); hold on;
							for(iCell = 1:50)
								plot3( t, iCell*ones(size(obj.activityParams.timeline)), fr{iCond}(iCell, :, iTrial) );
							end
							set(gca, 'xlim', [-150 550], 'view', [14.7560 19.3337], 'fontsize', 20, 'linewidth', 2);
							if(iTrial==4) ylabel('Neuron'); end
							if(iTrial==1) xlabel('Time (ms)'); end
							zlabel('Firing rate');
						end
					end

					figure('color', 'w'); hold on;
					[data, r] = hist( squeeze(sum(mean(fr{1}(:, 0<=t & t<=500, :), 1), 2)), 50 );
					thresh = prctile( squeeze(sum(mean(fr{1}(:, 0<=t & t<=500, :), 1), 2)), 96 );
					plot(r, data / sum(data) / (r(2)-r(1)), 'b-', 'lineWidth', 2);
					
					[data, r] = hist( squeeze(sum(mean(fr{2}(:, 0<=t & t<=500, :), 1), 2)), 50 );
					plot(r, data / sum(data) / (r(2)-r(1)), 'r-', 'lineWidth', 2);
					plot([1 1]*thresh, get(gca, 'ylim'), 'k-', 'lineWidth', 3);
					xlabel('Accumulate population mean FR (spikes/s)');
					ylabel('Probability density');
					set(gca, 'fontsize', 20, 'lineWidth', 2);
				end

			end
		end


		function MeanPopulationActivity(obj, withInternalNoise)
			%% Plot the profile of mean activity of a population of example cells
			if(~exist('withInternalNoise', 'var') || isempty(withInternalNoise))
				withInternalNoise = false;
			end

			if(isempty(obj.activityParams))
				fprintf('Please load activities with Encoder.LoadExampleCellsActivities() first!\n');
				return;
			end

			if(~exist('alignEvent', 'var') || isempty(alignEvent))
				alignEvent = 'saccadeOff';
			end

			conditions = obj.activityParams.conditions;

			SFs = unique([conditions.sf]);
			SFs(SFs == 0) = [];
			Eccs = [0 4 10];%unique([conditions.eccentricity]);

			figure( 'NumberTitle', 'off', 'name', 'Mean FR of Example Cells', 'color', 'w' );
			pause(0.1);
			jf = get(handle(gcf),'javaframe');
			jf.setMaximized(1);
			pause(1);
			colors = {'r', 'g', 'b'};
			for(k = 10:-1:1)
			    hAxes(k) = axes( 'Position', [0.06+0.96/5*(mod(k-1,5)), 0.08+0.92/2*(k<6), 0.96/5-0.03, 0.9/2-0.04], ...
			                     'xlim', [-150 550], 'xtick', -100:200:500, 'fontsize', 18, 'LineWidth', 2, 'nextplot', 'add' );
			    if(k > 5)
			        xlabel('Time (ms)');
			    else
			        set(gca, 'XTickLabel', []);
			        if(k < 5)
			        	title(obj.layers(k).name);
			        else
			        	title('Layers Average');
			        end
			    end
			    if(k == 1 || k == 6)
			        ylabel({sprintf('%d cpd', SFs((k>1)+1)), 'Firing rate (spikes/s)'});
			    end

			    iSF = (k>5) + 1;
                iL = mod(k-1, 5) + 1;
			    h = [];
			    for(iEcc = size(Eccs,2) : -1 : 1)
			    	iCond = [conditions.eccentricity] == Eccs(iEcc) & [conditions.sf] == SFs(iSF);
			    	tMin = max( round( obj.activityParams.timeline(1)/1000*[obj.activityParams.trials.sRate] ) + [obj.activityParams.trials.(conditions(iCond).alignEvent)] - [obj.activityParams.trials.(alignEvent)] );
					tMax = min( round( obj.activityParams.timeline(end)/1000*[obj.activityParams.trials.sRate] ) + [obj.activityParams.trials.(conditions(iCond).alignEvent)] - [obj.activityParams.trials.(alignEvent)] );
					t = (tMin:tMax) / obj.activityParams.trials(1).sRate * 1000;
					
					if(iL ~= 5)
						frBG = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise);
						fr = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise);
					else
						frBG = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise));
						fr = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise));
					end
					%% for saccade stabilized
					% g = gradient(mean(mean(frBG, 1) ,3));
					% k = find(t >= 0 & g > 0, 1, 'first');
					% frBG(:, k:end, :) = max(0, frBG(:, k:end, :) - frBG(:, k-1, :));
					% frBG(:, find(t==0) : k-1, :) = 0;
					% g = gradient(mean(mean(fr, 1) ,3));
					% k = find(t >= 0 & g > 0, 1, 'first');
					% fr(:, k:end, :) = max(0, fr(:, k:end, :) - fr(:, k-1, :));
					% fr(:, find(t==0) : k-1, :) = 0;

					frBG = mean(frBG, 1);	% mean population activity
	                mBG = mean(frBG, 3);
	                semBG = std(frBG, [], 3) / sqrt(size(frBG,3));
                    qua25BG = prctile(frBG, 25, 3);
                    qua75BG = prctile(frBG, 75, 3);

	                fr = mean(fr, 1);		% mean population activity
					m = mean(fr, 3);
					sem = std(fr, [], 3) / sqrt(size(fr,3));
                    qua25 = prctile(fr, 25, 3);
                    qua75 = prctile(fr, 75, 3);
    
                    % fill( [t, t(end:-1:1)], [m-qua25, m(end:-1:1)+qua75(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					fill( [t, t(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					h(iEcc) = plot( t, m, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Grating ecc=%d', Eccs(iEcc)) );

                    % fill( [t, t(end:-1:1)], [mBG-qua25BG, mBG(end:-1:1)+qua75BG(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					fill( [t, t(end:-1:1)], [mBG-semBG, mBG(end:-1:1)+semBG(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					h(size(Eccs,2)+1) = plot( t, mBG, '-.', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', 'Natural noise' );
					
					
                    drawnow;
                end
                h(size(Eccs,2)+2) = plot( [0 0], [0, max(get(gca, 'ylim'))], 'k--', 'lineWidth', 2, 'displayName', 'Saccade off' );
                h(size(Eccs,2)+3) = plot( [1 1] * mean(([obj.activityParams.trials.saccadeOn] - [obj.activityParams.trials.(alignEvent)]) ./ [obj.activityParams.trials.sRate]*1000), get(gca, 'ylim'), '--', 'color', [0.5 0.5 0.5], 'lineWidth', 2, 'displayName', 'Mean SacOn' );
                drawnow;
                
                if(k == 5)
                    legend(h, 'location', 'northeast');
                end

                set(gca, 'ylim', [0 max(get(gca, 'ylim'))]);
			end
		end


		function AccumulatedPopulationActivity(obj, withInternalNoise)
			%% Plot the profile of accumulated activity of a population of example cells
			if(~exist('withInternalNoise', 'var') || isempty(withInternalNoise))
				withInternalNoise = false;
			end

			if(isempty(obj.activityParams))
				fprintf('Please load activities with Encoder.LoadExampleCellsActivities() first!\n');
				return;
			end

			if(~exist('alignEvent', 'var') || isempty(alignEvent))
				alignEvent = 'saccadeOff';
			end
			if(~exist('timeRange', 'var') || isempty(timeRange))
				timeRange = [0 550];
			end

			conditions = obj.activityParams.conditions;

			SFs = unique([conditions.sf]);
			SFs(SFs == 0) = [];
			Eccs = unique([conditions.eccentricity]);

			figure( 'NumberTitle', 'off', 'name', 'Mean FR of Example Cells', 'color', 'w' );
			pause(0.1);
			jf = get(handle(gcf),'javaframe');
			jf.setMaximized(1);
			pause(1);
			colors = {'r', 'g', 'b'};
			for(k = 10:-1:1)
			    hAxes(k) = axes( 'Position', [0.06+0.96/5*(mod(k-1,5)), 0.08+0.92/2*(k<6), 0.96/5-0.03, 0.9/2-0.04], ...
			                     'xlim', [-10 550], 'xtick', -100:200:500, 'fontsize', 18, 'LineWidth', 2, 'nextplot', 'add' );
			    if(k > 5)
			        xlabel('Time (ms)');
			    else
			        set(gca, 'XTickLabel', []);
			        if(k < 5)
			        	title(obj.layers(k).name);
			        else
			        	title('Layers Average');
			        end
			    end
			    if(k == 1 || k == 6)
			        ylabel({sprintf('%d cpd', k*2), 'Firing rate (spikes/s)'});
			    end

			    iSF = (k>5) + 1;
                iL = mod(k-1, 5) + 1;
			    h = [];
			    for(iEcc = size(Eccs,2) : -1 : 1)
					t = timeRange(1) : timeRange(2);
                    
                    if(iL ~= 5)
						frBG = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise);
						fr = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise);
					else
						frBG = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise), ...
									  obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end]), false, withInternalNoise));
						fr = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise), ...
								    obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), SFs(iSF), 0.5, alignEvent, t([1 end]), false, withInternalNoise));
					end
					%% for saccade stabilized
					% g = gradient(mean(mean(frBG, 1) ,3));
					% k = find(t >= 0 & g > 0, 1, 'first');
					% frBG(:, k:end, :) = max(0, frBG(:, k:end, :) - frBG(:, k-1, :));
					% frBG(:, find(t==0) : k-1, :) = 0;
					% g = gradient(mean(mean(fr, 1) ,3));
					% k = find(t >= 0 & g > 0, 1, 'first');
					% fr(:, k:end, :) = max(0, fr(:, k:end, :) - fr(:, k-1, :));
					% fr(:, find(t==0) : k-1, :) = 0;

					frBG = cumsum(mean(frBG, 1), 2);% ./ (1:size(frBG,2));	% accumulated population activity
	                mBG = mean(frBG, 3);
	                semBG = std(frBG, [], 3) / sqrt(size(frBG,3));

	                fr = cumsum(mean(fr, 1), 2);% ./ (1:size(fr,2));		% accumulated population activity
					m = mean(fr, 3);
					sem = std(fr, [], 3) / sqrt(size(fr,3));

					fill( [t, t(end:-1:1)], [m-sem, m(end:-1:1)+sem(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					h(iEcc) = plot( t, m, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Grating ecc=%d', Eccs(iEcc)) );

					fill( [t, t(end:-1:1)], [mBG-semBG, mBG(end:-1:1)+semBG(end:-1:1)], colors{iEcc}, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
					h(size(Eccs,2)+1) = plot( t, mBG, '-.', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', 'Natural noise' );
					
					h(size(Eccs,2)+2) = plot( [0 0], [0, max(get(gca, 'ylim'))], 'k--', 'lineWidth', 2, 'displayName', 'Saccade off' );
					% h(size(Eccs,2)+3) = plot( [1 1] * mean([obj.activityParams.trials.saccadeOn] - [obj.activityParams.trials.(alignEvent)]) ./ [obj.activityParams.trials.sRate]*1000, get(gca, 'ylim'), '--', 'color', [0.5 0.5 0.5], 'lineWidth', 2, 'displayName', 'Mean SacOn' );

                    drawnow;
                end
                if(k == 5)
                    legend(h, 'location', 'northwest');
                end

                set(gca, 'ylim', [0 max(get(gca, 'ylim'))]);
			end
		end


		function FalseAlarmRate(obj, sbj, dataFolder, durOffset, alignEvent, timeRange)
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data';
			end

			if(~exist('durOffset', 'var') || isempty(durOffset))
				durOffset = 50+7;			% resonse delay of 50 ms + online saccade off later by 7 ms
			end

			if(isempty(obj.activityParams))
				fprintf('Please load activities with Encoder.LoadExampleCellsActivities() first!\n');
				return;
			end

			if(~exist('alignEvent', 'var') || isempty(alignEvent))
				alignEvent = 'saccadeOff';
			end
			if(~exist('timeRange', 'var') || isempty(timeRange))
				timeRange = [0 550];	% ms
			end

			T = timeRange(1) : timeRange(2);	% ms

			figure( 'NumberTitle', 'off', 'name', 'Dynamics of the detection threshold and the mean & sigma of the absent distribution', 'color', 'w' );
			pause(0.1);
			jf = get(handle(gcf),'javaframe');
			jf.setMaximized(1);
			pause(1);
			colors = {'r', 'g', 'b'};
			h = []; h2 = [];

			conditions = obj.activityParams.conditions;
            Eccs = unique([conditions.eccentricity]);
            nEccs = size(Eccs, 2);
            SFs = unique([conditions.sf]);
            nSFs = size(SFs, 2);

            cellNumAmplifier =cat(1, obj.layers.nAllCells) ./ cat(1,obj.layers.nExampleCells);		% inverse of proportion of cells used
			cellNumAmplifier(5,:) = mean(cellNumAmplifier,1);

            [fpr, nNoPresent, durs, ~] = EmpiricalBox.FalsePositiveRate(sbj);
			fpr = nansum(fpr .* nNoPresent, 2) ./ sum(nNoPresent, 2);			% all conditions are mixed within blocks, therefore the non-present condition has no eccentricity
			fprFun = @(dur) max(0, interp1(durs(:,1), fpr, dur, 'linear', 'extrap'));		% get false positive rate according to duration and eccentricity

			trials = EmpiricalBox.LoadSingleData(fullfile(dataFolder, [sbj, '.mat']));
			nTrials = zeros(nEccs, nSFs);
			contrasts = cell(nEccs, nSFs);
			nTrialsAbsent = sum(~[trials.present]);
			idxAbsent = randi(100, 1, nTrialsAbsent);
			lrFR = cell(5, nEccs, nSFs);
			frBG = cell(5,nEccs);
			fr = cell(5,nEccs);
			fa4Eccs = zeros(5,nEccs,size(T,2));
			threshold4Eccs = fa4Eccs;
			falseAlarmRate = zeros(5,size(T,2));
			for(iEcc = 1 : size(nTrials,1))
				for(iSF = 1 : size(nTrials,2))
					if(SFs(iSF) == 0)
						nTrials(iEcc, iSF) = sum([trials.eccentricity] == Eccs(iEcc) & ~[trials.present]);
					else
						idx = [trials.eccentricity] == Eccs(iEcc) & [trials.present] & [trials.spatialFreq] == SFs(iSF);
						nTrials(iEcc, iSF) = sum(idx);
						contrasts{iEcc, iSF} = [trials(idx).contrast];
					end
					for(iL = 1:5)
						if(iL < 5)
							lrFR{iL,iEcc,iSF} = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, Eccs(iEcc), SFs(iSF), 1, alignEvent, timeRange, true);
						else
							lrFR{iL,iEcc,iSF} = cat(1, lrFR{1,iEcc,iSF}, lrFR{2,iEcc,iSF}, lrFR{3,iEcc,iSF}, lrFR{4,iEcc,iSF});
						end
					end
				end
				idx1 = randi(100, 1, nTrials(iEcc,2));
				idx2 = randi(100, 1, nTrials(iEcc,3));
				for(iL = 1:5)
					frBG{iL,iEcc} = max(0, lrFR{iL,iEcc,1}(:,:,idxAbsent));		% for noise  trials
					fr{iL,iEcc} = cat(3, max(0, lrFR{iL,iEcc,1}(:,:,idx1) + lrFR{iL,iEcc,2}(:,:,idx1) .* reshape(contrasts{iEcc,2}, 1, 1, [])), ...		% for trials with the stimulus
									  max(0, lrFR{iL,iEcc,1}(:,:,idx2) + lrFR{iL,iEcc,3}(:,:,idx2) .* reshape(contrasts{iEcc,3}, 1, 1, [])));

					fr{iL,iEcc} = squeeze(cumsum(mean(fr{iL,iEcc}, 1), 2) ./ (1:size(fr{iL,iEcc},2)));		% mean accumulated population activity
					m = mean(fr{iL,iEcc}, 2);
					SD = std(fr{iL,iEcc}, [], 2) / sqrt(cellNumAmplifier(iL,iEcc));
					fr{iL,iEcc} = (fr{iL,iEcc} - m) / sqrt(cellNumAmplifier(iL,iEcc)) + m;	% compensate for the low sampling 
					%% for saccade stabilized
					% g = gradient(mean(mean(fr, 1) ,3));
					% k = find(t >= 0 & g > 0, 1, 'first');
					% fr(:, k:end, :) = max(0, fr(:, k:end, :) - fr(:, k-1, :));
					% fr(:, find(t==0) : k-1, :) = 0;

					frBG{iL,iEcc} = squeeze(cumsum(mean(frBG{iL,iEcc}, 1), 2) ./ (1:size(frBG{iL,iEcc},2)));		% mean accumulated population activity
					m = mean(frBG{iL,iEcc}, 2);
					SD = std(frBG{iL,iEcc}, [], 2) / sqrt(cellNumAmplifier(iL,iEcc));
					frBG{iL,iEcc} = (frBG{iL,iEcc} - m) / sqrt(cellNumAmplifier(iL,iEcc)) + m;	% compensate for the low sampling

					for(iTick = size(T,2) : -1 : 1)
						% threshold(iTick) = prctile( frBG(1,iTick,:), 100 * (1 - fprFun(t(iTick)-durOffset)) );		% set threshold at the level giving false alarm rate measured empirically
						% fa(iTick) = fmincon(@(x) , 100*fprFun(t(iTick)-durOffset), [], [], [], [], 0, 100, [], optimoptions('fmincon','Display','off'));
						x = 0:0.001:100;
						[err, k] = min((prctile(frBG{iL,iEcc}(iTick,:), 100-x) - prctile(fr{iL,iEcc}(iTick,:), x)).^2);
	                    if(err < 1e-12)
	                        fa4Eccs(iL, iEcc, iTick) = x(k);
	                        threshold4Eccs(iL, iEcc, iTick) = prctile(frBG{iL,iEcc}(iTick,:), 100-x(k));
	                    else
	                        threshold4Eccs(iL, iEcc, iTick) = (prctile(frBG{iL,iEcc}(iTick,:), 100-x(k)) + prctile(fr{iL,iEcc}(iTick,:), x(k))) / 2;
	                        fa4Eccs(iL, iEcc, iTick) = sum(frBG{iL,iEcc}(iTick,:) > threshold4Eccs(iL, iEcc, iTick)) / size(frBG{iL,iEcc},2) * 100;
	                    end
					end
				end

				subplot(2,2,1); hold on;
				h(iEcc) = plot( T-durOffset, m, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('\\mu, Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Accumulated average firing rate (spikes/s)'});
				title(sprintf('\\mu | Threshold'));
	            
				subplot(2,2,2); hold on;
				plot( T-durOffset, SD, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Standard deviation (spikes/s)'});
				title(sprintf('\\sigma'));

				subplot(2,2,1); hold on;
				h(iEcc+size(Eccs,2)) = plot( T-durOffset, squeeze(threshold4Eccs(5,iEcc,:)), '--', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('threshold, Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				% ylabel({'Threshold (spikes/s)'});
				% title(sprintf('Threshold'));

				subplot(2,2,3); hold on;
				plot( T-durOffset, squeeze(threshold4Eccs(5,iEcc,:)) - m(:), '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Accumulated average firing rate (spikes/s)'});
				title(sprintf('Threshold - \\mu'));

				subplot(2,2,4); hold on;
				h2(iEcc) = plot( T-durOffset, squeeze(fa4Eccs(5,iEcc,:)), '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'False alarm rate (%)'});
				title(sprintf('False Alarm'));

				drawnow;
            end

            for(iL = 1:5)
            	for(iTick = size(T,2) : -1 : 1)
	            	falseAlarmRate(iL,iTick) = sum(frBG{iL,1}(iTick,:) > threshold4Eccs(iL, 1, iTick) | frBG{iL,2}(iTick,:) > threshold4Eccs(iL, 2, iTick) | frBG{iL,3}(iTick,:) > threshold4Eccs(iL, 3, iTick)) / size(frBG{iL,1},2);
	            end
	        end

            subplot(2,2,4);
            h2(end+1) = plot( T-durOffset, 100*falseAlarmRate(5,:), 'k-', 'lineWidth', 2, 'displayName', 'Overall prediction');
            % h2(end+1) = plot( T-durOffset, 100*fprFun(T-durOffset), 'k--', 'lineWidth', 2, 'displayName', 'Empirical' );
            h2(end+1) = plot( [50 150 500], 100*fprFun([50 150 500]), 'k--', 'marker', 'o', 'MarkerSize', 10, 'lineWidth', 2, 'displayName', 'Empirical' );
            legend(h2, 'location', 'northeast');

            subplot(2,2,1);
            legend(h, 'location', 'northeast');
        	set(findobj(gcf, 'type', 'axes'), 'fontsize', 18, 'LineWidth', 2);

        	if(~isfield(obj.activityParams, 'FA'))
	        	obj.activityParams.FA = containers.Map();
	        end
	        obj.activityParams.FA(sbj) = struct( 'fa4Eccs', 		fa4Eccs,...
												 'threshold4Eccs',	threshold4Eccs,...
												 'falseAlarmRate',	falseAlarmRate,...
												 'alignEvent',		alignEvent,...
												 'T', 				T,...
												 'durOffset', 		durOffset);

		end


		function DetectionDynamics(obj, durOffset, alignEvent, timeRange)
			%% plot the dynamics of the detection threshold and the mean & sigma of the absent distribution
			if(~exist('durOffset', 'var') || isempty(durOffset))
				durOffset = 50+7;			% resonse delay of 50 ms + online saccade off later by 7 ms
			end

			if(isempty(obj.activityParams))
				fprintf('Please load activities with Encoder.LoadExampleCellsActivities() first!\n');
				return;
			end

			if(~exist('alignEvent', 'var') || isempty(alignEvent))
				alignEvent = 'saccadeOff';
			end
			if(~exist('timeRange', 'var') || isempty(timeRange))
				timeRange = [0 550];
			end

			conditions = obj.activityParams.conditions;
            Eccs = unique([conditions.eccentricity]);
            SFs = unique([conditions.sf]);
            iSF = 2;

			sbj = 'A014';
			[fpr, nNoPresent, durs, ~] = EmpiricalBox.FalsePositiveRate(sbj);
			fpr = nansum(fpr .* nNoPresent, 2) ./ sum(nNoPresent, 2);			% all conditions are mixed within blocks, therefore the non-present condition has no eccentricity
			fprFun = @(dur) max(0, interp1(durs(:,1), fpr, dur, 'linear', 'extrap'));		% get false positive rate according to duration and eccentricity

			cellNumAmplifier = mean(cat(1, obj.layers.nAllCells) ./ cat(1,obj.layers.nExampleCells), 1);		% inverse of proportion of cells used

			figure( 'NumberTitle', 'off', 'name', 'Dynamics of the detection threshold and the mean & sigma of the absent distribution', 'color', 'w' );
			pause(0.1);
			jf = get(handle(gcf),'javaframe');
			jf.setMaximized(1);
			pause(1);
			colors = {'r', 'g', 'b'};
			h = []; h2 = [];
		    for(iEcc = size(Eccs,2) : -1 : 1)
				t = timeRange(1) : timeRange(2);
            	frBG = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end])), ...
                              obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end])), ...
                              obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end])), ...
                              obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), 0, 0, alignEvent, t([1 end])));

            	contrast = 0.08;
            	fr = cat(1, obj.ExampleCellsActivitiesOnCondition(obj.layers(1).name, Eccs(iEcc), SFs(iSF), contrast, alignEvent, t([1 end])), ...
						    obj.ExampleCellsActivitiesOnCondition(obj.layers(2).name, Eccs(iEcc), SFs(iSF), contrast, alignEvent, t([1 end])), ...
						    obj.ExampleCellsActivitiesOnCondition(obj.layers(3).name, Eccs(iEcc), SFs(iSF), contrast, alignEvent, t([1 end])), ...
						    obj.ExampleCellsActivitiesOnCondition(obj.layers(4).name, Eccs(iEcc), SFs(iSF), contrast, alignEvent, t([1 end])));
            	fr = cumsum(mean(fr, 1), 2) ./ (1:size(fr,2));		% mean accumulated population activity
				m = mean(fr, 3);
				SD = std(fr, [], 3) / sqrt(cellNumAmplifier(iEcc));
				fr = (fr - m) / sqrt(cellNumAmplifier(iEcc)) + m;	% compensate for the low sampling 
				%% for saccade stabilized
				% g = gradient(mean(mean(fr, 1) ,3));
				% k = find(t >= 0 & g > 0, 1, 'first');
				% fr(:, k:end, :) = max(0, fr(:, k:end, :) - fr(:, k-1, :));
				% fr(:, find(t==0) : k-1, :) = 0;

				frBG = cumsum(mean(frBG, 1), 2) ./ (1:size(frBG,2));		% mean accumulated population activity
				m = mean(frBG, 3);
				SD = std(frBG, [], 3) / sqrt(cellNumAmplifier(iEcc));
				frBG = (frBG - m) / sqrt(cellNumAmplifier(iEcc)) + m;	% compensate for the low sampling

				for(iTick = size(t,2) : -1 : 1)
					% threshold(iTick) = prctile( frBG(1,iTick,:), 100 * (1 - fprFun(t(iTick)-durOffset)) );		% set threshold at the level giving false alarm rate measured empirically
					% fa(iTick) = fmincon(@(x) , 100*fprFun(t(iTick)-durOffset), [], [], [], [], 0, 100, [], optimoptions('fmincon','Display','off'));
					x = 0:0.001:100;
					[err, k] = min((prctile(frBG(1,iTick,:), 100-x) - prctile(fr(1,iTick,:), x)).^2);
                    if(err < 1e-12)
                        fa(iTick) = x(k);
                        threshold(iTick) = prctile(frBG(1,iTick,:), 100-x(k));
                    else
                        threshold(iTick) = (prctile(frBG(1,iTick,:), 100-x(k)) + prctile(fr(1,iTick,:), x(k))) / 2;
                        fa(iTick) = sum(frBG(1,iTick,:) > threshold(iTick)) / size(frBG,3) * 100;
                    end
				end

		    	subplot(2,2,1); hold on;
				h(iEcc) = plot( t-durOffset, m, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('\\mu, Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Mean accumulated firing rate (spikes/s)'});
				title(sprintf('\\mu | Threshold'));
	            
				subplot(2,2,2); hold on;
				plot( t-durOffset, SD, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Standard deviation (spikes/s)'});
				title(sprintf('\\sigma'));

				subplot(2,2,1); hold on;
				h(iEcc+size(Eccs,2)) = plot( t-durOffset, threshold, '--', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('threshold, Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				% ylabel({'Threshold (spikes/s)'});
				% title(sprintf('Threshold'));

				subplot(2,2,3); hold on;
				plot( t-durOffset, threshold - m, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'Threshold (spikes/s)'});
				title(sprintf('Threshold - \\mu'));

				subplot(2,2,4); hold on;
				h2(iEcc) = plot( t-durOffset, fa, '-', 'color', colors{iEcc}, 'lineWidth', 2, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
				xlabel('Post-saccadic duration (ms)');
				ylabel({'False alarm rate (%)'});
				title(sprintf('False Alarm'));

				drawnow;
            end
            subplot(2,2,4);
            h2(end+1) = plot( t-durOffset, 100*fprFun(t-durOffset), 'k--', 'lineWidth', 2, 'displayName', 'Empirical' );
            legend(h2, 'location', 'northeast');

            subplot(2,2,1);
            legend(h, 'location', 'northeast');
        	set(findobj(gcf, 'type', 'axes'), 'fontsize', 18, 'LineWidth', 2);
		end


		function TrialByTrialPrediction(obj)
			%% Trial-by-trial prediction of participant's report

		end


		function fr = ExampleCells4TrialPredict(obj, FR, time, conditions, trials, trialsIdx, cellIdx, applyRectify, alignEvent, LBOffset, UBOffset, saveFolder)
			if( nargin() < 9 || isempty(applyRectify) )
				applyRectify = true;
			end
			if( nargin() < 12 )
				saveFolder = [];
			end

			nTrials = size( FR{1}, 3 );
			idx = trialsIdx{1}(1:nTrials);

			Eccs = unique([conditions.eccentricity]);
			nEccs = size(Eccs,2);

			nRows = size( unique([conditions.eccentricity]), 2 );
			nCols = 4;

			fr = cell(size(conditions,2),5);
			for( iL = 1 : 5 )
				if( iL ~= 5 )
					layerName = obj.layers(iL).name;
				else
					layerName = 'Layers Average';
				end
				figure( 'NumberTitle', 'off', 'name', sprintf('Example Cells : Trial-by-Trial Prediction : %s+[%d,%d] : %s', alignEvent, LBOffset, UBOffset, layerName), 'color', 'w' );
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);

				colors = {'b', 'g', 'r'};
				lineStyles = {'-', '-.', '--'};
				names = {'Absent', '2 cpd', '10 cpd'};
				for(iCond = 1 : size(conditions,2))
					iEcc = find( conditions(iCond).eccentricity == Eccs );
					iSF = find( conditions(iCond).sf == [2 10] );
					iDur = find( conditions(iCond).duration == [500] );
					iPre = find( conditions(iCond).present == [0 1] );
					k = iSF + iPre - 1;

					if( iL ~= 5 )
						tmpFR = FR{iCond,iL}(:,:,:);
						if(applyRectify)
							tmpFR(tmpFR<0) = 0;
                        end
						
                        fr{iCond,iL} = zeros(size(FR{iCond,iL},1), UBOffset - LBOffset + 1, nTrials);
						for( iTrial = 1 : nTrials )
							s = find( time{iCond} >= round( ( trials(idx(iTrial)).(alignEvent) - trials(idx(iTrial)).(conditions(iCond).alignEvent) ) / trials((idx(iTrial))).sRate * 1000 ), 1, 'first' );
							fr{iCond,iL}(:,:,iTrial) = tmpFR(:,s+(LBOffset:UBOffset),iTrial);
						end
					else
						fr{iCond,iL}(:,:,:) = cat( 1, fr{iCond,1}(:,:,:), fr{iCond,2}(:,:,:), fr{iCond,3}(:,:,:), fr{iCond,4}(:,:,:) );
					end

					%% Mean (accumulated) firing rate across cell population for each trial
					subplot( nRows, nCols, (iEcc-1)*nCols + 1 ); hold on;
					h = plot( squeeze( mean( sum(fr{iCond,iL}(:,:,:), 2), 1 ) ), 'lineStyle', lineStyles{k}, 'lineWidth', 2, 'color', colors{k}, 'displayName', names{k} );
					% if( iEcc == 1 )
					% 	hs(k) = h;
					% end
					
					if( k == 3 )
						set( gca, 'fontsize', 18, 'lineWidth', 2 );
						title( sprintf('Ecc=%d', conditions(iCond).eccentricity) );
						if( iEcc == 2 )
							ylabel( sprintf('Population mean FR') );
						end
						% if( iEcc == 1 )
						% 	legend( hs, 'location', 'northwest' );
						% end
						if( iEcc == nRows )
							xlabel('Trial index');
						end
					end

					%% Prabability density of population mean (accumulated) firing rate across trials
					subplot( nRows, nCols, (iEcc-1)*nCols + 2 ); hold on;
					points = squeeze( mean( sum(fr{iCond,iL}(:,:,:), 2), 1 ) )';
					st = max(points) / (round(nTrials/3));
					edges = -st/2+min(points) : st : max(points)+st+st/2;
					cnts = histc( points, edges ); cnts(end) = [];
					cnts = cnts / sum(cnts) / (edges(2)-edges(1));
					h = plot( (edges(1:end-1)+edges(2:end))/2, cnts, 'LineStyle', lineStyles{k}, 'color', colors{k}, 'lineWidth', 2, 'displayName', names{k} );
					if( iEcc == 1 )
						hs(k) = h;
					end

					if( k == 3 )
						set( gca, 'fontsize', 18, 'lineWidth', 2 );
						% title( sprintf('Ecc=%d | %s+[%d,%d]', conditions(iCond).eccentricity, alignEvent, LBOffset, UBOffset) );
						if( iEcc == 2 )
							ylabel( sprintf('Probability density') );
						end
						if( iEcc == 1 )
							set( legend( hs, 'location', 'northeast' ), 'position', [0.4627, 0.8528, 0.0552, 0.0884] );
						end
						if( iEcc == nRows )
							xlabel('Population mean FR');
						end
					end

					%% ROC by thresholding
					if( k==2 || k==3 )
						subplot( nRows, nCols, (iEcc-1)*nCols + 3 ); hold on;
						t = [zeros(1,nTrials), ones(1,nTrials)];
						data = cat( 4, fr{iEcc+([1 k]-1)*nEccs, iL} );
						y = reshape( mean( sum(data,2), 1 ), 1, [] );
						y = (y-min(y)) / (max(y)-min(y));
						[tpr, fpr, th] = roc( t, y );
						plot( fpr, tpr, 'lineWidth', 2, 'color', colors{k} );
						text( 1, (4-k)*0.2-0.1, sprintf( 'AUC: %.4f', AreaUnderROC( unique( [tpr;fpr]', 'rows' ) ) ), 'fontsize', 18, 'color', colors{k}, 'horizontalAlignment', 'right', 'verticalAlignment', 'bottom' );

						if( k == 3 )
							set( gca, 'fontsize', 18, 'lineWidth', 2 );
							if( iEcc == 1 )
								title('Thresholding Classifier');
							end
							if( iEcc == 2 )
								ylabel( sprintf('Correct detection rate') );
							end
							if( iEcc == nRows )
								xlabel('False alarm rate');
							end
						end
					end


					%% ROC with GLM classifier
					if( k == 3 )
						subplot( nRows, nCols, (iEcc-1)*nCols + 4 ); hold on;
						data = cat( 4, fr{iEcc+(0:2)*nEccs, iL} );
						X = reshape( mean( data, 2 ), size(data,1), [] )';
						T = [zeros(1,nTrials), ones(1,nTrials*2)]';
						N = round(nTrials/3*2);
						nBoots = 3;
						for(iBoot = nBoots:-1:1)
							rndIdx = [randperm(nTrials), randperm(nTrials)+nTrials, randperm(nTrials)+nTrials*2];
							trainIdx = [1:N, (1:N)+nTrials, (1:N)+2*nTrials];
							mdl = fitglm( X(rndIdx(trainIdx),:), T(rndIdx(trainIdx)), 'linear', 'distribution', 'binomial' );
							for( m = 1 : 2 )
								testIdx = [N+1:nTrials, (N+1:nTrials)+nTrials*m];
								[tpr, fpr] = roc( T(rndIdx(testIdx))', mdl.predict(X(rndIdx(testIdx),:))' );	% True Positive Rate, False Positive Rate
								AUC(m,iBoot) = AreaUnderROC( unique( [tpr;fpr]', 'rows' ) );
							end
						end

						for( m = 1 : 2 )
							M = mean(AUC(m,:));
							sd = std(AUC(m,:));
							plot( m, M, 's', 'color', colors{m+1}, 'markersize', 8, 'lineWidth', 2 );
							plot( [m m], M+[-1 1]*sd, 'lineWidth', 2, 'color', colors{m+1} );
							text( m, 0.1, sprintf( '%.4f\\pm\n%.4f', M, sd ), 'fontsize', 14, 'color', colors{m+1}, 'horizontalAlignment', 'center', 'verticalAlignment', 'bottom' );
						end

						set( gca, 'xlim', [0 3], 'ylim', [0 1.1], 'xtick', [1 2], 'XTickLabel', {'2 cpd', '10 cpd'}, 'fontsize', 18, 'lineWidth', 2 );
						if( iEcc == 2 )
							ylabel( sprintf('AUC') );
						end
						if( iEcc == 1 )
							title('GLM Classifier');
						end
						if( iEcc == nRows )
							xlabel( sprintf('Bootstrap AUC (%d)', nBoots) );
						end
					end
				end
				if( ~isempty(saveFolder) && exist(saveFolder,'dir') )
					saveas( gcf, fullfile( saveFolder, sprintf( 'Trial-by-Trial Prediction, %s+[%d,%d], %s.fig', alignEvent, LBOffset, UBOffset, layerName ) ) );
					saveas( gcf, fullfile( saveFolder, sprintf( 'Trial-by-Trial Prediction, %s+[%d,%d], %s.png', alignEvent, LBOffset, UBOffset, layerName ) ) );
				end
			end

			% [coef, scores, latent] = pca( fr );
			% scores = [xVel;yVel]' * coef;
			% plot( [0 coef(1,1)*sqrt(latent(1))], [0 coef(2,1)*sqrt(latent(1))], '-', 'color', colors{iCond}, 'LineWidth', 2 );
			% plot( [0 coef(1,2)*sqrt(latent(2))], [0 coef(2,2)*sqrt(latent(2))], '--', 'color', colors{iCond}, 'LineWidth', 2 );
		end


		function [tTicks, tprAccPredict, tprSegPredict] = TrialPredict(obj, classifier, contrast, alignEvent, timeRange, tStep, tWin, saveFolder, durOffset, withInternalNoise)
			
			if( ~exist('timeRange', 'var') || isempty(timeRange) )
				timeRange = [0 600];
			end
			if( ~exist('tStep', 'var') || isempty(tStep) )
				tStep = 10;
			end
			if( ~exist('tWin', 'var') || isempty(tWin) )
				tWin = 50;
			end
			if( ~exist('saveFolder', 'var') || isempty(saveFolder) )
				saveFolder = [];
			end
			if( ~exist('durOffset', 'var') || isempty(durOffset) )
				durOffset = 50 + 7;			% resonse delay of 50 ms + online saccade off later by 7 ms
			end
			if( ~exist('withInternalNoise', 'var') )
				withInternalNoise = false;
			end
			tWin = round(tWin/2)*2;

			sbj = 'A014';
			if(strcmpi(classifier, 'thresholding-uni-optim_fa'))		% optimal false alarm rate from distributions of human experimental conditions
				if(~isfield(obj.activityParams, 'FA') || ~obj.activityParams.FA.isKey(sbj) || ~strcmpi(obj.activityParams.FA(sbj).alignEvent, alignEvent) || obj.activityParams.FA(sbj).T(1) > timeRange(1) || obj.activityParams.FA(sbj).T(end) < timeRange(2))
					obj.FalseAlarmRate(sbj, [], durOffset, alignEvent, timeRange);
				end
			else
				[fpr, nNoPresent, durs, ~] = EmpiricalBox.FalsePositiveRate(sbj);
				fpr = nansum(fpr .* nNoPresent, 2) ./ sum(nNoPresent, 2);			% all conditions are mixed within blocks, therefore the non-present condition has no eccentricity
				fprFun = @(dur) max(0, interp1(durs(:,1), fpr, dur, 'linear', 'extrap'));		% get false positive rate according to duration and eccentricity
				% fprFun = @(dur) mean(fpr);
			end

			classifiers = {'threshold-Uni', 'thresholding-TW_Uni', 'thresholding-TW_pVal', 'IdealObserver', 'GLM', 'FLDA', 'FLDA_Time', 'FLDA_Single'};
			% classifier = classifiers{1};

			nTrials = size(obj.activityParams.trials,2);

			conditions = obj.activityParams.conditions;
			Eccs = unique([conditions.eccentricity]);
			nEccs = size(Eccs,2);

			SFs = unique([conditions.sf]);
			nSFs = size(SFs,2);

			tTicks = timeRange(1) : tStep : timeRange(2);
			tprAccPredict = nan(5,2,nEccs,size(tTicks,2));		% true positive rate predicted by accumulated firing rate in the segment of [LBOffset, tTicks(k)]; layers X SFs X Eccs X time
			tprSegPredict = tprAccPredict;						% true positive rate predicted by accumulated firing rate in the segment of [-tWin/2,tWin/2]+tTicks(k); layers X SFs X Eccs X time
            tprAccPredictSD = tprAccPredict;
            tprSegPredictSD = tprSegPredict;
            
			frAcc = cell(size(conditions,2),5);
			frSeg = frAcc;

			cellNumAmplifier =cat(1, obj.layers.nAllCells) ./ cat(1,obj.layers.nExampleCells);		% inverse of proportion of cells used
			cellNumAmplifier(5,:) = mean(cellNumAmplifier,1);

			for(iCond = size(conditions,2) : -1 : 1)
				for(iL = 4:-1:1)
					LFR{iCond,iL} = obj.ExampleCellsActivitiesOnCondition(obj.layers(iL).name, conditions(iCond).eccentricity, conditions(iCond).sf, contrast, alignEvent, timeRange, false, withInternalNoise);
					% if(withInternalNoise)
					% 	g = gradient(mean(mean(LFR{iCond,iL}, 1) ,3));
					% 	t = timeRange(1) : timeRange(2);
					% 	k = find(t >= 0 & g > 0, 1, 'first');
					% 	LFR{iCond,iL}(:, k:end, :) = max(0, LFR{iCond,iL}(:, k:end, :) - LFR{iCond,iL}(:, k-1, :));
					% 	LFR{iCond,iL}(:, find(t==0) : k-1, :) = 0;
					% end
				end
			end

			for(iTick = 1 : size(tTicks,2))
				for( iL = 1 : 5 )
					for(iCond = 1 : size(conditions,2))
						if( iL ~= 5 )
	                        frAcc{iCond,iL} = LFR{iCond,iL}(:, 1 : tTicks(iTick)-timeRange(1)+1, :);
	                        % frSeg{iCond,iL} = LFR{iCond,iL}(:, max(1, tTicks(iTick)-tWin/2-timeRange(1)+1) : min(size(LFR{iCond,iL},2), tTicks(iTick)+tWin/2-timeRange(1)+1), :);
						else
							frAcc{iCond,iL} = cat( 1, frAcc{iCond,1}(:,:,:), frAcc{iCond,2}(:,:,:), frAcc{iCond,3}(:,:,:), frAcc{iCond,4}(:,:,:) );
							% frSeg{iCond,iL} = cat( 1, frSeg{iCond,1}(:, max(1, tTicks(iTick)-tWin/2-timeRange(1)+1) : min(size(LFR{iCond,1},2), tTicks(iTick)+tWin/2-timeRange(1)+1), :),...
							% 						  frSeg{iCond,2}(:, max(1, tTicks(iTick)-tWin/2-timeRange(1)+1) : min(size(LFR{iCond,2},2), tTicks(iTick)+tWin/2-timeRange(1)+1), :),...
							% 						  frSeg{iCond,3}(:, max(1, tTicks(iTick)-tWin/2-timeRange(1)+1) : min(size(LFR{iCond,3},2), tTicks(iTick)+tWin/2-timeRange(1)+1), :),...
							% 						  frSeg{iCond,4}(:, max(1, tTicks(iTick)-tWin/2-timeRange(1)+1) : min(size(LFR{iCond,4},2), tTicks(iTick)+tWin/2-timeRange(1)+1), :) );
						end
					end

					for(iCond = 1 : size(conditions,2))
						iEcc = find( conditions(iCond).eccentricity == Eccs );
						iSF = find( conditions(iCond).sf == SFs );
						k = iSF;

						switch(lower(classifier))							
							case 'thresholding-uni'
								%% ROC with thresholding, uniform weights across space and time
								if( k > 1 )
									T = [zeros(1,nTrials), ones(1,nTrials)];
									data = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = ones(1,size(data,2));		% uniform temporal weight
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									thresholdAcc{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick)-durOffset)) );		% set threshold at the level giving false alarm rate measured empirically
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdAcc{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									% data = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									% w = ones(1,size(data,2));		% uniform temporal weight
									% w = w / sum(w);
									% y = w * shiftdim(nanmean(data,1),1);
									% y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									% y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% y = (y-min(y)) / (max(y)-min(y));
									% % if(tTicks(iTick) <= 50)
									% 	thresholdSeg{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving false alarm rate measured empirically
									% % end
									% tprSegPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdSeg{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									% tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'thresholding-uni-no_bias'
								%% ROC with thresholding, uniform weights across space and time
								if( k > 1 )
									T = [zeros(1,nTrials), ones(1,nTrials)];
									data = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = ones(1,size(data,2));		% uniform temporal weight
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% fa = fmincon(@(x) double(prctile(y(T==0), 100-x) - prctile(y(T==1), x))^2, 100*fprFun(tTicks(iTick)-durOffset), [], [], [], [], 0, 100, [], optimoptions('fmincon','Display','off'));
									% thresholdAcc{iCond,iL} = prctile( y(T==0), 100 - fa );
									x = 0:0.001:100;
									[err, idx] = min((prctile(y(T==0), 100-x) - prctile(y(T==1), x)).^2);
				                    if(err < 1e-12)
				                        thresholdAcc{iCond,iL} = prctile( y(T==0), 100 - x(idx) );
				                    else
				                        thresholdAcc{iCond,iL} = (prctile(y(T==0), 100-x(idx)) + prctile(y(T==1), x(idx))) / 2;
				                    end

									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdAcc{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									% data = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									% w = ones(1,size(data,2));		% uniform temporal weight
									% w = w / sum(w);
									% y = w * shiftdim(nanmean(data,1),1);
									% y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									% y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% y = (y-min(y)) / (max(y)-min(y));
									% % fa = fmincon(@(x) double(prctile(y(T==0), 100-x) - prctile(y(T==1), x))^2, 100*fprFun(tTicks(iTick)-durOffset), [], [], [], [], 0, 100, [], optimoptions('fmincon','Display','off'));
									% % thresholdSeg{iCond,iL} = prctile( y(T==0), 100 - fa );
									% x = 0:0.001:100;
									% [err, k] = min((prctile(y(T==0), 100-x) - prctile(y(T==1), x)).^2);
				     %                if(err < 1e-12)
				     %                    thresholdSeg{iCond,iL} = prctile( y(T==0), 100 - x(k) );
				     %                else
				     %                    thresholdSeg{iCond,iL} = (prctile(y(T==0), 100-x(k)) + prctile(y(T==1), x(k))) / 2;
				     %                end
									% tprSegPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdSeg{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									% tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'thresholding-uni-optim_fa'
								%% ROC with thresholding, uniform weights across space and time, and the false alarm rate was determined according to optimal thresholding
								if( k > 1 )
									data = frAcc([conditions.sf] == 0, iL);		% absent activity at all eccs
									data{iEcc} = frAcc{iCond, iL};
									w = ones(1, size(data{1},2));		% uniform temporal weight
									w = w / sum(w);
									y = cellfun(@(x) w * shiftdim(nanmean(x,1), 1), data, 'UniformOutput', false);
									for(ii = 1:nEccs)
										y{ii} = (y{ii} - mean(y{ii})) / sqrt(cellNumAmplifier(iL,ii)) + mean(y{ii});
									end
									iT = find(tTicks(iTick) == obj.activityParams.FA('A014').T);
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( y{1} > obj.activityParams.FA(sbj).threshold4Eccs(iL,1,iT) |...
																			y{2} > obj.activityParams.FA(sbj).threshold4Eccs(iL,2,iT) |...
																			y{3} > obj.activityParams.FA(sbj).threshold4Eccs(iL,3,iT)  ) / size(y{1},2);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									data = frSeg([conditions.sf] == 0, iL);		% absent activity at all eccs
									data{iEcc} = frSeg{iCond, iL};
									w = ones(1, size(data{1},2));		% uniform temporal weight
									w = w / sum(w);
									y = cellfun(@(x) w * shiftdim(nanmean(x,1), 1), data, 'UniformOutput', false);
									for(ii = 1:nEccs)
										y{ii} = (y{ii} - mean(y{ii})) / sqrt(cellNumAmplifier(iL,ii)) + mean(y{ii});
									end
									tprSegPredict(iL,k-1,iEcc,iTick) = sum( y{1} > obj.activityParams.FA(sbj).threshold4Eccs(iL,1,iT) |...
																			y{3} > obj.activityParams.FA(sbj).threshold4Eccs(iL,2,iT) |...
																			y{3} > obj.activityParams.FA(sbj).threshold4Eccs(iL,3,iT)  ) / size(y{1},2);	% true positive rate of prediction
									tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'thresholding-sw_sine-tw_uni'
								%% ROC with thresholding, sine wave spatial weights and uniform temporal weights
								% 	For this approach, we combine ON and OFF cells
								if( k > 1 && any(iL == [2,4,5]) )		% 1-POn, 2-POff, 3-MOn, 4-MOff, 5-All
									if(iL ~= 5)
										dataOn = cat( 3, frAcc{[iCond-k+1,iCond], iL-1} );	% catenate in the trials dimension
										dataOff = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
										rfLocOn = obj.layers(iL-1).locations( obj.layers(iL-1).idxExampleCells{iEcc}, : );
										rfLocOff = obj.layers(iL).locations( obj.layers(iL).idxExampleCells{iEcc}, : );
									else
										dataOn = cat( 1, cat( 3, frAcc{[iCond-k+1,iCond], 1} ), cat( 3, frAcc{[iCond-k+1,iCond], 3} ) );
										dataOff = cat( 1, cat( 3, frAcc{[iCond-k+1,iCond], 2} ), cat( 3, frAcc{[iCond-k+1,iCond], 4} ) );
										rfLocOn = [obj.layers(1).locations( obj.layers(1).idxExampleCells{iEcc}, : ); obj.layers(3).locations( obj.layers(3).idxExampleCells{iEcc}, : )];
										rfLocOff = [obj.layers(2).locations( obj.layers(2).idxExampleCells{iEcc}, : ); obj.layers(4).locations( obj.layers(4).idxExampleCells{iEcc}, : )];
									end
									wOn = cos( 2*pi*SFs(iSF) * (sqrt(sum(rfLocOn.^2,2))' - Eccs(iEcc)) ) / 2 + 0.5;		% column vector
									wOff = -cos( 2*pi*SFs(iSF) * (sqrt(sum(rfLocOff.^2,2))' - Eccs(iEcc)) ) / 2 + 0.5;
									w = [wOn, wOff];
									w = w / sum(w);
									y = w * squeeze(nanmean([dataOn; dataOff],2));

									T = [zeros(1,nTrials), ones(1,nTrials)];
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdAcc{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdAcc{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									if(iL ~= 5)
										dataOn = cat( 3, frSeg{[iCond-k+1,iCond], iL-1} );	% catenate in the trials dimension
										dataOff = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
										rfLocOn = obj.layers(iL-1).locations( obj.layers(iL-1).idxExampleCells{iEcc}, : );
										rfLocOff = obj.layers(iL).locations( obj.layers(iL).idxExampleCells{iEcc}, : );
									else
										dataOn = cat( 1, cat( 3, frSeg{[iCond-k+1,iCond], 1} ), cat( 3, frSeg{[iCond-k+1,iCond], 3} ) );
										dataOff = cat( 1, cat( 3, frSeg{[iCond-k+1,iCond], 2} ), cat( 3, frSeg{[iCond-k+1,iCond], 4} ) );
										rfLocOn = [obj.layers(1).locations( obj.layers(1).idxExampleCells{iEcc}, : ); obj.layers(3).locations( obj.layers(3).idxExampleCells{iEcc}, : )];
										rfLocOff = [obj.layers(2).locations( obj.layers(2).idxExampleCells{iEcc}, : ); obj.layers(4).locations( obj.layers(4).idxExampleCells{iEcc}, : )];
									end
									wOn = cos( 2*pi*SFs(iSF) * (sqrt(sum(rfLocOn.^2,2))' - Eccs(iEcc)) ) / 2 + 0.5;		% column vector
									wOff = -cos( 2*pi*SFs(iSF) * (sqrt(sum(rfLocOff.^2,2))' - Eccs(iEcc)) ) / 2 + 0.5;
									w = [wOn, wOff];
									w = w / sum(w);
									y = w * squeeze(nanmean([dataOn; dataOff],2));

									T = [zeros(1,nTrials), ones(1,nTrials)];
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdSeg{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprSegPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdSeg{iCond,iL}) == T & T == 1 ) / sum(T==1);	% true positive rate of prediction
									tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'thresholding-sw_uni-tw_pval'
								%% ROC with thresholding, uniform spatial weights, p-values as temporal weights
								if( k > 1 )
									T = [zeros(1,nTrials), ones(1,nTrials)];
									data = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = zeros(1,size(data,2));		% temporal weight by seperation of two distributions
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										[~,w(iT)] = ttest2( r(T==0), r(T==1) );
										w(iT) = 1 - w(iT);			% smaller p-value corresponds to greater weight
									end
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdAcc{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdAcc{iCond,iL}) == T & T == 1 ) / size(y(T==1),2);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									data = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = zeros(1,size(data,2));		% temporal weight by seperation of two distributions
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										[~,w(iT)] = ttest2( r(T==0), r(T==1) );
										w(iT) = 1 - w(iT);			% smaller p-value corresponds to greater weight
									end
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdSeg{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprSegPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdSeg{iCond,iL}) == T & T == 1 ) / size(y(T==1),2);	% true positive rate of prediction
									tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'thresholding-sw_uni-tw_dprime'
								%% ROC with thresholding, uniform spatial weights, d-prime as temporal weights
								if( k > 1 )
									T = [zeros(1,nTrials), ones(1,nTrials)];
									data = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = zeros(1,size(data,2));		% temporal weight by seperation of two distributions
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										w(iT) = max(0, (mean(r(T==1)) - mean(r(T==0))) / sqrt(var(r(T==1) + var(r(T==0)))));
									end
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdAcc{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdAcc{iCond,iL}) == T & T == 1 ) / size(y(T==1),2);	% true positive rate of prediction
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									data = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									w = zeros(1,size(data,2));		% temporal weight by seperation of two distributions
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										[~,w(iT)] = ttest2( r(T==0), r(T==1) );
										w(iT) = 1 - w(iT);			% smaller p-value corresponds to greater weight
									end
									w = w / sum(w);
									y = w * shiftdim(nanmean(data,1),1);
									y(T==0) = (y(T==0) - mean(y(T==0))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==0));	% compensate for the low sampling
									y(T==1) = (y(T==1) - mean(y(T==1))) / sqrt(cellNumAmplifier(iL,iEcc)) + mean(y(T==1));	% compensate for the low sampling
									% if(tTicks(iTick) <= 50)
										thresholdSeg{iCond,iL} = prctile( y(T==0), 100 * (1 - fprFun(tTicks(iTick))) );		% set threshold at the level giving 10%~5% false alarm rate
									% end
									tprSegPredict(iL,k-1,iEcc,iTick) = sum( (y > thresholdSeg{iCond,iL}) == T & T == 1 ) / size(y(T==1),2);	% true positive rate of prediction
									tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'idealobserver'
								%% Bayesian inference as ideal observer
								if( k > 1 )
									T = [zeros(1,nTrials), ones(1,nTrials)];
									data = cat( 3, frAcc{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									logP = 0;
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										m0 = mean(r(T==0));
										sd0 = std(r(T==0));
										m1 = mean(r(T==1));
										sd1 = std(r(T==1));
										sd0 = sd0 / sqrt(cellNumAmplifier(iL,iEcc));	% compensate for the low sampling
										sd1 = sd1 / sqrt(cellNumAmplifier(iL,iEcc));	% compensate for the low sampling
										logP = logP + log(normpdf(r,m1,sd1)) - log(normpdf(r,m0,sd0));
									end
									tprAccPredict(iL,k-1,iEcc,iTick) = sum( (logP >= 0) == T  ) / size(T,2);	% correct rate
									tprAccPredictSD(iL,k-1,iEcc,iTick) = 0;
									
									data = cat( 3, frSeg{[iCond-k+1,iCond], iL} );	% catenate in the trials dimension
									logP = 0;
									for( iT = 1 : size(data,2) )
										r = squeeze( mean(data(:,iT,:), 1) )';	% average across neurons
										if( any(isnan(r)) )
											continue;
										end
										m0 = mean(r(T==0));
										sd0 = std(r(T==0));
										m1 = mean(r(T==0));
										sd1 = std(r(T==0));
										sd0 = sd0 / sqrt(cellNumAmplifier(iL,iEcc));	% compensate for the low sampling
										sd1 = sd1 / sqrt(cellNumAmplifier(iL,iEcc));	% compensate for the low sampling
										logP = logP + log(normpdf(r,m1,sd1)) - log(normpdf(r,m0,sd0));
									end
									tprSegPredict(iL,k-1,iEcc,iTick) = sum( (logP >= 0) == T ) / size(T,2);	% correct rate
									tprSegPredictSD(iL,k-1,iEcc,iTick) = 0;
								end

							case 'glm'
								%% ROC with GLM classifier
								if( k == 3 )
									data = {cat(4, frAcc{iEcc+(0:2)*nEccs, iL}), cat(4, frAcc{iEcc+(0:2)*nEccs, iL})};
									for( ii = 2:-1:1 )
										X = reshape( nanmean(data{ii},2), size(data{ii},1), [] )';
										[coef, scores, latent] = pca(X);
										iLat = 0; s = 0; upperLat = sum(latent) * 0.95;	% 99% of variance
										while( s < upperLat )
											iLat = iLat+1;
											s = s + latent(iLat);
										end
										iLat = 4;
										X = scores(:, 1:iLat);
										T = [zeros(1,nTrials), ones(1,nTrials*2)]';
										N = round(nTrials/3*2);
										nBoots = 3;
										for(iBoot = nBoots:-1:1)
											rndIdx = [randperm(nTrials), randperm(nTrials)+nTrials, randperm(nTrials)+nTrials*2];
											trainIdx = [1:N, (1:N)+nTrials, (1:N)+2*nTrials];
											mdl = fitglm( X(rndIdx(trainIdx),:), T(rndIdx(trainIdx)), 'linear', 'distribution', 'binomial' );
											for( m = 2:-1:1 )
												predicts = mdl.predict(X(rndIdx(trainIdx),:));
												[tpr, fpr] = roc( T(rndIdx(trainIdx))', predicts' );	% True Positive Rate, False Positive Rate
												[~,iThresh] = max(tpr-fpr);
												threshold = sort(unique(predicts), 'descend');
												threshold = threshold(iThresh-1);
												testIdx = [N+1:nTrials, (N+1:nTrials)+nTrials*m];
												AUC(m,iBoot) = sum( (mdl.predict(X(rndIdx(testIdx),:)) > threshold) == T(rndIdx(testIdx)) ) / size(testIdx,2);		% prediction correct rate
												% [tpr, fpr] = roc( T(rndIdx(testIdx))', mdl.predict(X(rndIdx(testIdx),:))' );	% True Positive Rate, False Positive Rate
												% AUC(m,iBoot) = AreaUnderROC( unique( [tpr;fpr]', 'rows' ) );
											end
										end
										auc(ii,1,:) = mean(AUC,2);
										auc(ii,2,:) = std(AUC,[],2);
									end
									tprAccPredict(iL,:,iEcc,iTick) = auc(1,1,:);
									tprAccPredictSD(iL,:,iEcc,iTick) = auc(1,2,:);
									tprSegPredict(iL,:,iEcc,iTick) = auc(2,1,:);
									tprSegPredictSD(iL,:,iEcc,iTick) = auc(2,2,:);
								end
								
							case 'flda'
								%% ROC with Fisher's Linear Discriminant Analysis
								% each variable/dimenstion corresponds to a cell's mean firing rate across time, each trial corresponds to one sample
								if( k == 3 )
									data = { frAcc{iEcc,iL}, cat(4, frAcc{iEcc+(1:2)*nEccs,iL}); frSeg{iEcc,iL}, cat(4, frSeg{iEcc+(1:2)*nEccs,iL}) };
									for( ii = 2:-1:1 )
										X1 = reshape( nanmean(data{ii,1},2), size(data{ii,1},1), [] );
										X2 = reshape( nanmean(data{ii,2},2), size(data{ii,2},1), [] );
										[coef, scores, latent] = pca( [X1,X2]' );
										iLat = 0; s = 0; upperLat = sum(latent) * 0.80;	% 99% of variance
										while( s < upperLat )
											iLat = iLat+1;
											s = s + latent(iLat);
										end
										X1 = scores(1:nTrials, 1:iLat-1)';
										X2 = scores(nTrials+1:end, 1:iLat-1)';
										T1 = false(1,nTrials);
										T2 = true(1,nTrials*2);
										N = round(nTrials/3*2);
										trainIdx1 = 1:N;
										trainIdx2 = [1:N, nTrials+(1:N)];
										testIdx1 = N+1:nTrials;
										testIdx2 = (0:1)'*nTrials+(N+1:nTrials);
										nBoots = 3;
										for(iBoot = nBoots:-1:1)
											rndIdx1 = randperm(nTrials);
											rndIdx2 = [randperm(nTrials), randperm(nTrials)+nTrials];
											mu1 = mean( X1(:,rndIdx1(trainIdx1)), 2 );
											mu2 = mean( X2(:,rndIdx2(trainIdx2)), 2 );
											S1 = X1(:,rndIdx1(trainIdx1)) - mu1;	S1 = S1 * S1';
											S2 = X2(:,rndIdx2(trainIdx2)) - mu2;	S2 = S2 * S2';
											W = inv(S1+S2)' * (mu1-mu2);	% Fisher Discriminant vector
											for( m = 2:-1:1 )
												F = W' * [X1(:,rndIdx1(testIdx1)), X2(:,rndIdx2(testIdx2(m,:)))];
												predicts = F < W' * (mu1+mu2)/2;		% false for class 1, true for class 2
												AUC(m,iBoot) = sum( predicts == [T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(m,:)))] ) / size(predicts,2);	% prediction correct rate
												% [tpr, fpr] = roc( [T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(m,:)))], F );	% True Positive Rate, False Positive Rate
												% AUC(m,iBoot) = AreaUnderROC( unique( [tpr;fpr]', 'rows' ) );
											end
										end
										auc(ii,1,:) = mean(AUC,2);
										auc(ii,2,:) = std(AUC,[],2);
									end
									tprAccPredict(iL,:,iEcc,iTick) = auc(1,1,:);
									tprAccPredictSD(iL,:,iEcc,iTick) = auc(1,2,:);
									tprSegPredict(iL,:,iEcc,iTick) = auc(2,1,:);
									tprSegPredictSD(iL,:,iEcc,iTick) = auc(2,2,:);
								end

							case 'flda_time'
								%% ROC with Fisher's Linear Discriminant Analysis
								% each variable/dimenstion corresponds to one cell's firing rate at a specific time point, each trial corresponds to one sample
								if( k == 3 )
									data = { frAcc{iEcc,iL}, cat(4, frAcc{iEcc+(1:2)*nEccs,iL}); frSeg{iEcc,iL}, cat(4, frSeg{iEcc+(1:2)*nEccs,iL}) };
									for( ii = 2:-1:1 )
										if( isempty(data{ii,1}) || isempty(data{ii,2}) || ii == 2 )
											auc(ii,1:2,1:2) = 0;
											continue;
										end
										X1 = reshape( data{ii,1}, size(data{ii,1},1), [] );
										X2 = reshape( data{ii,2}, size(data{ii,2},1), [] );
										[coef, scores, latent] = pca( [X1,X2]' );
										iLat = 0; s = 0; upperLat = sum(latent) * 0.80;	% 99% of variance
										while( s < upperLat )
											iLat = iLat+1;
											s = s + latent(iLat);
										end
                                        X1 = reshape( scores(:,1:iLat)', iLat, size(data{ii,1},2), [] );
 										X2 = X1(:,:,nTrials+1:end);
                                        X1 = X1(:,:,1:nTrials);
                                        
										T1 = false(1,nTrials);
										T2 = true(1,nTrials*2);
										N = round(nTrials/3*2);
										trainIdx1 = 1:N;
										trainIdx2 = [1:N, nTrials+(1:N)];
										testIdx1 = N+1:nTrials;
										testIdx2 = (0:1)'*nTrials+(N+1:nTrials);
										nBoots = 3;
										
										if( iTick == size(tTicks,2) && ii == 1 )
											Weights{iEcc,iL} = zeros(size(X1,1),1);
										end
										
										for(iBoot = nBoots:-1:1)
											rndIdx1 = randperm(nTrials);
											rndIdx2 = [randperm(nTrials), randperm(nTrials)+nTrials];
											xx1 = reshape( X1(:,:,rndIdx1(trainIdx1)), size(X1,1), [] );
											xx2 = reshape( X2(:,:,rndIdx2(trainIdx2)), size(X2,1), [] );
											mu1 = mean( xx1, 2 );
											mu2 = mean( xx2, 2 );
											S1 = xx1 - mu1;	S1 = S1 * S1';
											S2 = xx2 - mu2;	S2 = S2 * S2';
											W = inv(S1+S2)' * (mu1-mu2);	% Fisher Discriminant vector
											if( iTick == size(tTicks,2) && ii == 1 )
												Weights{iEcc,iL} = Weights{iEcc,iL} + W;
											end
											for( m = 2:-1:1 )
												F = W' * [reshape( X1(:,:,rndIdx1(testIdx1)), size(X1,1), [] ), reshape( X2(:,:,rndIdx2(testIdx2(m,:))), size(X2,1), [] )];
												predicts = F < W' * (mu1+mu2)/2;		% false for class 1, true for class 2
												predicts = mean( reshape(predicts, size(data{ii,1},2), []), 1 ) > 0.5;
												AUC(m,iBoot) = sum( predicts == [T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(m,:)))] ) / size(predicts,2);	% prediction correct rate
												% [tpr, fpr] = roc( [T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(m,:)))], F );	% True Positive Rate, False Positive Rate
												% AUC(m,iBoot) = AreaUnderROC( unique( [tpr;fpr]', 'rows' ) );
											end
										end
										auc(ii,1,:) = mean(AUC,2);
										auc(ii,2,:) = std(AUC,[],2);

										if( iTick == size(tTicks,2) && ii == 1 )
											Weights{iEcc,iL} = coef(:,1:size(X1,1)) * (Weights{iEcc,iL}/nBoots);
										end
									end
									tprAccPredict(iL,:,iEcc,iTick) = auc(1,1,:);
									tprAccPredictSD(iL,:,iEcc,iTick) = auc(1,2,:);
									tprSegPredict(iL,:,iEcc,iTick) = auc(2,1,:);
									tprSegPredictSD(iL,:,iEcc,iTick) = auc(2,2,:);
								end

							case 'flda_single'
								%% PCA + Fisher's Linear Discriminant Analysis in single neuron level; using time points as variables
								sigm = @(x) 1 ./ (1+exp(-x));	% sigmoid function
								if( k == 3 )
									data = { frAcc{iEcc,iL}, cat(4, frAcc{iEcc+(1:2)*nEccs,iL}); frSeg{iEcc,iL}, cat(4, frSeg{iEcc+(1:2)*nEccs,iL}) };
									for( ii = 2:-1:1 )
										N = round(nTrials/3*2);
										T1 = false(1,nTrials);
										T2 = true(1,nTrials*2);
										trainIdx1 = 1:N;
										trainIdx2 = [1:N, nTrials+(1:N)];
										testIdx1 = N+1:nTrials;
										testIdx2 = (0:1)'*nTrials+(N+1:nTrials);

										nBoots = 10;
										for(iBoot = nBoots:-1:1)
											rndIdx1 = randperm(nTrials);
											rndIdx2 = [randperm(nTrials), randperm(nTrials)+nTrials];

											p_present = zeros(2, (nTrials-N)*2, size(data{ii,1},1));
											for(iCell = 1 : size(data{ii,1},1))
												X1 = shiftdim(data{ii,1}(iCell,:,:), 1);
												X2 = shiftdim(data{ii,2}(iCell,:,:), 1);
												[coef, scores, latent] = pca( [X1,X2]' );
												iLat = min(size(scores,2),4);
												X1 = scores(1:nTrials, 1:iLat)';
												X2 = scores(nTrials+1:end, 1:iLat)';

												mu1 = mean( X1(:,rndIdx1(trainIdx1)), 2 );
												mu2 = mean( X2(:,rndIdx2(trainIdx2)), 2 );
												S1 = X1(:,rndIdx1(trainIdx1)) - mu1;	S1 = S1 * S1';
												S2 = X2(:,rndIdx2(trainIdx2)) - mu2;	S2 = S2 * S2';
												W = inv(S1+S2)' * (mu1-mu2);	% Fisher Discriminant vector
												for( m = 2:-1:1 )
													F = W' * [X1(:,rndIdx1(testIdx1)), X2(:,rndIdx2(testIdx2(m,:)))];
													predicts = F < W' * (mu1+mu2)/2;		% false for class 1, true for class 2
													p_present(m,:,iCell) = predicts;
												end
											end
											p_present = mean(p_present,3);
											AUC(:,iBoot) = sum( (p_present > 0.5) == [T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(1,:))); T1(rndIdx1(testIdx1)), T2(rndIdx2(testIdx2(2,:)))], 2 ) / ((nTrials-N)*2);
										end
										auc(ii,1,:) = mean(AUC,2);
										auc(ii,2,:) = std(AUC,[],2);
									end
									tprAccPredict(iL,:,iEcc,iTick) = auc(1,1,:);
									tprAccPredictSD(iL,:,iEcc,iTick) = auc(1,2,:);
									tprSegPredict(iL,:,iEcc,iTick) = auc(2,1,:);
									tprSegPredictSD(iL,:,iEcc,iTick) = auc(2,2,:);
								end

						end
					end
				end
			end


			%% plot figures
			nRows = size( unique([conditions.eccentricity]), 2 );
			nCols = 4;
			colors = {[0 0 1], [0 1 0], [1 0 0]};
			lineStyles = {'-', '-.', '--'};
			names = {'Absent', '2 cpd', '10 cpd'};
			
			for( iL = 1 : 5 )
				if( iL ~= 5 )
					layerName = obj.layers(iL).name;
				else
					layerName = 'Layers Average';
				end
				hFig = figure( 'NumberTitle', 'off', 'name', sprintf('Example Cells : Trial-by-Trial Prediction : %s+[%d,%d] : %s', alignEvent, timeRange(1), timeRange(2), layerName), 'color', 'w' );
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);

				figure(hFig);
				for(iCond = 1 : size(conditions,2))
					iEcc = find( conditions(iCond).eccentricity == Eccs );
					iSF = find( conditions(iCond).sf == [0 2 10] );
					k = iSF;

					%% Prabability density of population mean (accumulated) firing rate across trials
					subplot( nRows, nCols, (iEcc-1)*nCols + 1 ); hold on;
					points = squeeze( mean( nansum(frAcc{iCond,iL}(:,:,:), 2), 1 ) )';
					st = max(points) / (round(nTrials/3));
					edges = -st/2+min(points) : st : max(points)+st+st/2;
					cnts = histc( points, edges ); cnts(end) = [];
					cnts = cnts / sum(cnts) / (edges(2)-edges(1));
					h = plot( (edges(1:end-1)+edges(2:end))/2, cnts, 'LineStyle', lineStyles{k}, 'color', colors{k}, 'lineWidth', 2, 'displayName', names{k} );
					if( iEcc == 1 )
						hs(k) = h;
						legend( hs, 'location', 'northeast' );
					end

					if( k == 3 )
						set( gca, 'fontsize', 18, 'lineWidth', 2 );
						title( sprintf('Ecc=%d | %s+[%d,%d]', conditions(iCond).eccentricity, alignEvent, timeRange(1), timeRange(2)) );
						if( iEcc == 2 )
							ylabel( sprintf('Probability density') );
						end
						% if( iEcc == 1 )
						% 	set( legend( hs, 'location', 'northeast' ), 'position', [0.4627, 0.8528, 0.0552, 0.0884] );
						% end
						if( iEcc == nRows )
							xlabel('Population mean accumulated FR');
						end
					end
					drawnow;

					%% ROC by thresholding
					if( k==2 || k==3 )
						subplot( nRows, nCols, (iEcc-1)*nCols + 2 ); hold on;
						t = [zeros(1,nTrials), ones(1,nTrials)];
						data = cat( 4, frAcc{[iCond-k+1,iCond], iL} );
						y = reshape( mean( nansum(data,2), 1 ), 1, [] );
						y = (y-min(y)) / (max(y)-min(y));
						[tpr, fpr, th] = roc( t, y );
						plot( fpr, tpr, 'lineWidth', 2, 'color', colors{k} );
						text( 1, (4-k)*0.2-0.1, sprintf( 'AUC: %.4f', AreaUnderROC( unique( [tpr;fpr]', 'rows' ) ) ), 'fontsize', 18, 'color', colors{k}, 'horizontalAlignment', 'right', 'verticalAlignment', 'bottom' );
						% text( 1, (4-k)*0.2-0.1, sprintf( 'AUC: %.4f', tprAccPredict(iL,k-1,iEcc,end) ), 'fontsize', 18, 'color', colors{k}, 'horizontalAlignment', 'right', 'verticalAlignment', 'bottom' );

						if( k == 3 )
							set( gca, 'fontsize', 18, 'lineWidth', 2 );
							if( iEcc == 1 )
								title('Thresholding Classifier');
							end
							if( iEcc == 2 )
								ylabel( sprintf('Correct detection rate') );
							end
							if( iEcc == nRows )
								xlabel('False alarm rate');
							end
						end
						drawnow;
					end

					% %% AUC as a function of time computed with accumulated firing rate in the segment of [timeRange(1), tTicks(k)]
					% if( k > 1 )
					% 	subplot( 2, 2+2*useGLM, 2 ); hold on;
					% 	plot( tTicks, squeeze(accAUC(iL,k-1,iEcc,:)), 'color', colors{k}*(nEccs-iEcc+1)/nEccs, 'lineWidth', 2, 'displayName', sprintf('SF=%d, Ecc=%d', conditions(iCond).sf, conditions(iCond).eccentricity) );
					% 	if( k == 3 )
					% 		set( gca, 'fontsize', 18, 'lineWidth', 2 );
					% 		% set( legend, 'location', 'northwest' );
					% 		title('AUC Evolving over Time');
					% 		ylabel('AUC');
					% 	end
					% 	drawnow;
					% end

					% %% AUC as a function of time computed with firing rate in the segment [-tWin/2,tWin/2]+tTicks(k)
					% if( k > 1 )
					% 	subplot( 2, 2+2*useGLM, 4 ); hold on;
					% 	plot( tTicks, squeeze(segAUC(iL,k-1,iEcc,:)), 'color', colors{k}*(nEccs-iEcc+1)/nEccs, 'lineWidth', 2, 'displayName', sprintf('SF=%d, Ecc=%d', conditions(iCond).sf, conditions(iCond).eccentricity) );
					% 	if( k == 3 )
					% 		set( gca, 'fontsize', 18, 'lineWidth', 2 );
					% 		set( legend, 'location', 'northwest', 'position', [0.8998, 0.3585, 0.0979, 0.1732] );
					% 		title(sprintf('AUC in Sliding Window of %d ms',tWin));
					% 		xlabel(['Time aligned to ', alignEvent]);
					% 		ylabel('AUC');
					% 	end
					% 	drawnow;
					% end

					%% Classification performance
					if( k == 3 )
						for( m = 1 : 2 )
							subplot( 2, 2, 2 ); hold on;
							M = squeeze(tprAccPredict(iL,m,iEcc,:))';
							SD = squeeze(tprAccPredictSD(iL,m,iEcc,:))';
							plot( tTicks, M, 'color', colors{m+1}*(nEccs-iEcc+1)/nEccs, 'lineWidth', 2 );
							fill( [tTicks, tTicks(end:-1:1)], [M+SD, fliplr(M)-fliplr(SD)], colors{m}*(nEccs-iEcc+1)/nEccs, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
							set( gca, 'fontsize', 18, 'lineWidth', 2 );
							% title('AUC Evolving over Time');
							% ylabel('AUC');
							title('Prediction Evolving over Time');
							ylabel('Corerct rate');

							subplot( 2, 2, 4 ); hold on;
							M = squeeze(tprSegPredict(iL,m,iEcc,:))';
							SD = squeeze(tprSegPredictSD(iL,m,iEcc,:))';
							plot( tTicks, M, 'color', colors{m+1}*(nEccs-iEcc+1)/nEccs, 'lineWidth', 2 );
							fill( [tTicks, tTicks(end:-1:1)], [M+SD, fliplr(M)-fliplr(SD)], colors{m}*(nEccs-iEcc+1)/nEccs, 'LineStyle', 'none', 'FaceAlpha', 0.2 );
							set( gca, 'fontsize', 18, 'lineWidth', 2 );
							% title(sprintf('AUC in Sliding Window of %d ms',tWin));
							title(sprintf('Prediction in Sliding Window of %d ms',tWin));
							xlabel(['Time aligned to ', alignEvent]);
							% ylabel('AUC');
							ylabel('Corerct rate');
						end
					end
				end

				if( ~isempty(saveFolder) )
					if( ~exist(saveFolder,'dir') )
						mkdir(saveFolder);
					end
					saveas( gcf, fullfile( saveFolder, sprintf( 'Time Course of Trial-by-Trial Prediction with %s, %s+[%d,%d], %s.fig', classifier, alignEvent, timeRange(1), timeRange(2), layerName ) ) );
					saveas( gcf, fullfile( saveFolder, sprintf( 'Time Course of Trial-by-Trial Prediction with %s, %s+[%d,%d], %s.png', classifier, alignEvent, timeRange(1), timeRange(2), layerName ) ) );
					% save(tTicks, accAUC, segAUC, glmtprPredict, glmAccAUCsd, glmSegAUCm, glmtprSegPredictSD, frAcc, frSeg);
				end
			end

			% [coef, scores, latent] = pca( fr );
			% scores = [xVel;yVel]' * coef;
			% plot( [0 coef(1,1)*sqrt(latent(1))], [0 coef(2,1)*sqrt(latent(1))], '-', 'color', colors{iCond}, 'LineWidth', 2 );
			% plot( [0 coef(1,2)*sqrt(latent(2))], [0 coef(2,2)*sqrt(latent(2))], '--', 'color', colors{iCond}, 'LineWidth', 2 );
		end


		function [tTicks, accTPRm, Thresholds, ThresholdsSTD, segTPRm] = ContrastDetection(obj, classifier, CHANCE, dataFolder, durOffset, withInternalNoise)
			if( ~exist('classifier', 'var') || isempty(classifier) )
				classifier = 'thresholding-uni';
			end
			if( ~exist('CHANCE', 'var') || isempty(CHANCE) )
				CHANCE = 0.1;
			end
			if( ~exist('dataFolder', 'var') || isempty(dataFolder) )
				dataFolder = '../../Data/Simulated Activities\Noise & Grating Simulated Separately';
			end
			if( ~exist('durOffset', 'var') || isempty(durOffset) )
				durOffset = 50 + 7;		% resonse delay of 50 ms + online saccade off later by 7 ms 
			end
			if( ~exist('withInternalNoise', 'var') || isempty(withInternalNoise) )
				withInternalNoise = false;
			end
			
			targetRatio = (1-CHANCE)*(1-exp(-1)) + CHANCE;
			if(withInternalNoise)
				dataFolder = fullfile(dataFolder, 'figures - withInternalNoise', sprintf('%s - durOffset=%d', classifier, durOffset));
			else
				dataFolder = fullfile(dataFolder, 'figures', sprintf('%s - durOffset=%d', classifier, durOffset));
			end
			if(~exist(dataFolder, 'dir'))
				mkdir(dataFolder);
			end

			sbj = 'A014';
			[fpr, nNoPresent, durs_, ~] = EmpiricalBox.FalsePositiveRate(sbj);
			fpr = nansum(fpr .* nNoPresent, 2) ./ sum(nNoPresent, 2);			% all conditions are mixed within blocks, therefore the non-present condition has no eccentricity
			fprFun = @(dur) max(0, interp1(durs_(:,1), fpr, dur, 'linear', 'extrap'));
			% fprFun = @(dur) mean(fpr);
			
			conditions = obj.activityParams.conditions;
			
			contrasts = [0.01, 0.03, 0.05, 0.07, 0.09, 0.10, 0.30, 0.50, 0.70, 0.90, 1, 3, 5, 7, 9];
			% contrasts = 10.^linspace(-2, 2, 21);
			contrasts = 10.^linspace(-2, 2, 41);
			if( exist( fullfile(dataFolder, 'PerformanceData.mat') ) )
				load( fullfile(dataFolder, 'PerformanceData.mat') );
			else
				nJobs = 1;
				for(k = 1 : ceil(size(contrasts,2)/nJobs))
					% for( iContrast = 1 : size(contrasts,2) )
					for( iContrast = (k-1)*nJobs + 1 : min(size(contrasts,2), k*nJobs) )
						fprintf( 'Processing contrast=%.3f ...\n', contrasts(iContrast) );
						[tTicks{iContrast}, accTPRm(:,:,:,:,iContrast), segTPRm(:,:,:,:,iContrast)] = obj.TrialPredict(classifier, contrasts(iContrast), 'saccadeOff', [0 600], [], [], fullfile(dataFolder, sprintf('Trial-Prediction Time Course Contrast=%.2f', contrasts(iContrast))), durOffset, withInternalNoise);
						drawnow;
						pause(3);
						% for(iL = 5:-1:1)
	% 						saveas( gcf, fullfile( dataFolder, sprintf( 'Time Course of Trial-by-Trial Prediction with %s, %s+[%d,%d], %s.fig', classifier, 'saccadeOff', 0, 500, layerNames{iL} ) ) );
	% 						saveas( gcf, fullfile( dataFolder, sprintf( 'Time Course of Trial-by-Trial Prediction with %s, %s+[%d,%d], %s.png', classifier, 'saccadeOff', 0, 500, layerNames{iL} ) ) );
							% close(gcf);
						% end
						close all;
					end
				end
				tTicks = tTicks{1};
				save( fullfile(dataFolder, 'PerformanceData.mat'), 'tTicks', 'accTPRm', 'segTPRm', 'conditions', 'contrasts' );
			end

			Eccs = unique([conditions.eccentricity]);
			nEccs = size(Eccs,2);
			SFs = unique([conditions.sf]);
			SFs(SFs == 0) = [];
			nSFs = size(SFs,2);
			if( true||~exist('durs', 'var') )
				durs = [50 150 300 500];
				durs = [1 50 75 150 300 500];
				durs = [1 50 150 500];
                durs = 0:10:500;
			end
			layerNames = {'POn', 'POff', 'MOn', 'MOff', 'LayerAverage'};
			% durs = tTicks - durOffset;
            nDurs = size(durs,2);

			%% psychometric curves
			if( true||~exist('Thresholds', 'var') )
				Thresholds = zeros(size(layerNames,2),nSFs,nEccs,size(durs,2));
				ThresholdsSTD = Thresholds;
				Sensitivities = Thresholds;
				SensitivitiesSTD = Thresholds;
				fitThreshold = true;
			else
				fitThreshold = false;true;
			end
			for( iL = 1 : 5 )
				colors = { [0 1 0], [0 0.7 0], [0 0.4 0], [0 0.1 0]; ...	% for 2cpd
						   [1 0 0], [0.7 0 0], [0.4 0 0], [0.1 0 0] };		% for 10cpd
				colors = { [0 1 0], [0 0.775 0], [0 0.55 0], [0 0.325 0], [0 0.1 0]; ...	% for 2cpd
						   [1 0 0], [0.775 0 0], [0.55 0 0], [0.325 0 0], [0 0.1 0] };		% for 10cpd
				figure( 'NumberTitle', 'off', 'name', sprintf('Psychometric Curve - Prediction by AverageThresholding - %s', layerNames{iL}), 'color', 'w' );
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);
				for(iSF = 1 : nSFs)
					for(iEcc = 1 : nEccs)
						subplot( nSFs, nEccs, (iSF-1)*nEccs + iEcc ); hold on;
						for( iDur = 1 : nDurs )
							[~,iTick] = min(abs(tTicks - (durs(iDur)+durOffset)));
							% chance = CHANCE - max(0, durs(iDur)/500*0.05);
							% chance = fprFun(durs(iDur));
							chance = accTPRm(iL,iSF,iEcc,iTick,1);	% false alarm rate equals true positive rate when contrast level is small enough
							targetRatio = (1-chance)*(1-exp(-1)) + chance;
							h(iDur) = plot( contrasts, squeeze(accTPRm(iL,iSF,iEcc,iTick,:)), 'o', 'color', colors{iSF,1}*(nDurs-iDur+1)/nDurs, 'displayName', sprintf('%d ms', durs(iDur)), 'markersize', 8, 'lineWidth', 3 );
							plot( contrasts, squeeze(accTPRm(iL,iSF,iEcc,iTick,:)), '--', 'color', colors{iSF,1}*(nDurs-iDur+1)/nDurs, 'displayName', sprintf('%d ms', durs(iDur)), 'lineWidth', 1 );

							if(fitThreshold)
								if( ~any(isnan(accTPRm(iL,iSF,iEcc,iTick,:))) )
									nTrials = 100;%size(frSeg{1},3);
                                    % iMin = max(1, find(diff(accTPRm(iL,iSF,iEcc,iTick,:)) ./ accTPRm(iL,iSF,iEcc,iTick,1:end-1) >= 0.1, 1, 'first') - 1);
                                    % iMin = max(1, find(diff(accTPRm(iL,iSF,iEcc,iTick,:)) ./ accTPRm(iL,iSF,iEcc,iTick,1:end-1) >= 0.3, 1, 'first') - 1);
                                    N = 3;
                                    iMin = find(conv(diff(squeeze(accTPRm(iL,iSF,iEcc,iTick,:))') > 0, ones(1,N), 'same') == N, 1, 'first');
                                    iMin2 = max(1, find(accTPRm(iL,iSF,iEcc,iTick,:) <= chance, 1, 'last'));
                                    iMin = max(iMin, iMin2);
									iMax = find(accTPRm(iL,iSF,iEcc,iTick,:) == 1, 2, 'first');
									if(isempty(iMax))
										iMax = size(contrasts,2);
									else
										iMax = iMax(end);
									end
									if(isempty(iMin))
										iMin = 1;
									else
										iMin = iMin(1);
									end
									hits = zeros(1, nTrials*size(contrasts(iMin:iMax),2));
									for( iCont = iMin:iMax )
										hits( (iCont-iMin)*nTrials + ( 1 : round(nTrials * accTPRm(iL,iSF,iEcc,iTick,iCont)) ) ) = 1;
									end
									[~, ~, nThresh, nPar, g, chisq] = psyfit( reshape(repmat(contrasts(iMin:iMax),nTrials,1),1,[]), hits, 'Thresh', targetRatio, 'Chance', chance, 'Lapses', 0, 'Log', 'Extra', 'PlotOff', 'Boots', 10, 'disttype', 'normal' );
									goodIdx = ~isoutlier(nThresh) & ~isoutlier(nPar(1,:)) & ~isoutlier(nPar(2,:));
									par = mean(nPar,2);
									stdPar(2) = std(nPar(2,goodIdx));
									stdPar(1) = std(nPar(1,goodIdx));
									thresh = mean(nThresh(goodIdx));
									stdThresh = std(nThresh(goodIdx));
									sense = mean(1./nThresh(goodIdx));
									stdSense = std(1./nThresh(goodIdx));
									% x = linspace( 0, max(contrasts)*1.1, 10000 );
									% x = 1e-6:0.001:max(contrasts)*1.1;
									x = 10.^(linspace( -6, log10(max(contrasts)*1.1), 10000 ));
									y = psyfun( x, par(1), par(2), chance, 0, false, true, 'normal' );
									yLow = psyfun( x, par(1) - stdPar(1), par(2) - stdPar(2), 0.1, 0, false, true, 'normal' );
									yUp = psyfun( x, par(1) + stdPar(1), par(2) + stdPar(2), 0.1, 0, false, true, 'normal' );
									plot( x, y, '-', 'LineWidth', 2.5, 'color', colors{iSF,1}*(nDurs-iDur+1)/nDurs, 'DisplayName', sprintf('%d cpd, %d ms', SFs(iSF), durs(iDur)) );
									% set( fill( [x(2:end) x(end:-1:2)], [yLow(2:end) yUp(end:-1:2)], colors{iSF,iDur} ), 'LineStyle', 'none', 'FaceAlpha', 0.5 );
									plot( [1, 1] * thresh, [0, targetRatio], '--', 'color', colors{iSF,1}*(nDurs-iDur+1)/nDurs, 'lineWidth', 2 );
									% set( fill( [-1, 1, 1, -1]*stdThresh + thresh, [0, 0, targetRatio, targetRatio], colors{iSF,iDur} ), 'LineStyle', 'none', 'FaceAlpha', 0.5 );

									Thresholds(iL,iSF,iEcc,iDur) = thresh;
									ThresholdsSTD(iL,iSF,iEcc,iDur) = stdThresh;
									Sensitivities(iL,iSF,iEcc,iDur) = sense;
									SensitivitiesSTD(iL,iSF,iEcc,iDur) = stdSense;
								else
									Thresholds(iL,iSF,iEcc,iDur) = nan;
									ThresholdsSTD(iL,iSF,iEcc,iDur) = nan;
									Sensitivities(iL,iSF,iEcc,iDur) = nan;
									SensitivitiesSTD(iL,iSF,iEcc,iDur) = nan;
								end
							end
						end
						if(iSF == 1 && iEcc == 1)
							legend(h, 'location', 'southeast');
						end
						if(iSF == nSFs)
							xlabel('Contrast');
						end
						if(iEcc == 1)
							ylabel( {sprintf('SF=%d', SFs(iSF)), 'Proportion yes'} );
                        end
                        if(iSF == 1)
                            title(sprintf('Ecc = %d', Eccs(iEcc)));
                        end
						set( gca, 'xlim', [0.01 0.6], 'xscale', 'log', 'ylim', [0 1], 'lineWidth', 2, 'fontsize', 18 );
						drawnow;
					end
				end
				saveas( gcf, fullfile( dataFolder, sprintf('Psychometric Curve - Prediction by AverageThresholding - %s.fig', layerNames{iL}) ) );
				saveas( gcf, fullfile( dataFolder, sprintf('Psychometric Curve - Prediction by AverageThresholding - %s.png', layerNames{iL}) ) );
			end

			if(fitThreshold)
                save( fullfile(dataFolder, 'PerformanceData.mat'), 'tTicks', 'accTPRm', 'segTPRm', 'conditions', 'durs', 'Thresholds', 'ThresholdsSTD', 'Sensitivities', 'SensitivitiesSTD' );
			end


			%% contrast threshold as a function of stimulus duration
			figure( 'NumberTitle', 'off', 'name', sprintf('Contrast Threshold - Prediction by AverageThresholding - %s', layerNames{iL}), 'color', 'w' );
			for( iL = 1 : 5 )
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);
				nRows = nSFs;
				nCols = size(layerNames,2);
				colors = { [0 1 0], [0 0.6 0], [0 0.2 0]; ...	% for 2cpd
						   [1 0 0], [0.6 0 0], [0.2 0 0] };		% for 10cpd
				colors = {'r', 'g', 'b'};
				for(iSF = 1 : nSFs)
					subplot(nRows, nCols, (iSF-1)*nCols + iL); hold on; h = [];
					for(iEcc = 1 : nEccs)
                        durIdx = 1 : size(durs, 2);%[1,2,4,6];%
						m = squeeze(Thresholds(iL,iSF,iEcc,durIdx))';
						sd = squeeze(ThresholdsSTD(iL,iSF,iEcc,durIdx))';
						h(iEcc) = plot( durs(durIdx), m, 's', 'color', colors{iEcc}, 'markersize', 10, 'lineWidth', 3, 'displayName', sprintf('Ecc=%d', Eccs(iEcc)) );
						plot( durs(durIdx), m, '-', 'color', colors{iEcc}, 'lineWidth', 2 );
						plot( reshape([durs(durIdx); durs(durIdx); nan(size(durs(durIdx)))], 1, []), reshape([m+sd;m-sd;nan(size(durs(durIdx)))], 1, []), 'color', colors{iEcc}, 'lineWidth', 2 );
					end
					if(iSF == 1 && iL == 1)
						legend(h, 'location', 'southeast');
					end
					if(iSF == nSFs)
						xlabel('Duration (ms)');
					end
					if(iL == 1)
						ylabel( {sprintf('SF=%d', SFs(iSF)), 'Contrast threshold'} );
                    end
                    if(iSF == 1)
                        title(layerNames{iL});
                    end
					set( gca, 'xlim', [0 600], 'xtick', [1 50 150 500], 'ylim', [0.008 1], 'ytick', [0.01, 0.05, 0.1 0.5], 'xscale', 'linear', 'yscale', 'log', 'ydir', 'reverse', 'lineWidth', 2, 'fontsize', 18 );
					if( max(get(gca,'ylim')) > 1 )
						set( gca, 'ylim', [0 1] );
					end
					drawnow;
				end
			end
			saveas( gcf, fullfile( dataFolder, sprintf('Contrast Threshold - Prediction by AverageThresholding - %s.fig', layerNames{iL}) ) );
			saveas( gcf, fullfile( dataFolder, sprintf('Contrast Threshold - Prediction by AverageThresholding - %s.png', layerNames{iL}) ) );
			
		end


		function [img, inputX, inputY] = LoadNoise(obj, noiseFile, degPerPix)
			%% load noise background from the file specified by noiseFile
			%   noiseFile:			full file path for the noise
			%	degPerPix:			number of degrees per pixel
			%
			%   img:				image pixel values loaded from the file (range of [-1 1]); 1st dimension for vertical, 2nd for horizontal
			%	inputX:				horizontal coordinates of each pixel in img (deg)
			%	inputY:				vertical coordinates of each pixel in img (deg)

			f = fopen(noiseFile);
			w = 1920; h = 1080;
			img = zeros(w,h);
			img(:) = fread(f, w*h, 'float32');
			img = img(:,end:-1:1)'*2 - 1;
			inputX = ( (1:w) - (1+w)/2 ) * degPerPix;
			inputY = ( (1:h) - (1+h)/2 ) * degPerPix;
            fclose(f);
		end


		function [grating, inputX, inputY] = GenerateGrating(obj, sf, phase, degPerPix, radius, width_or_orient)
			%% generate a circular grating (radius >= 0) or a uniform grating across the whole image when radius < 0
			%	sf:					spatial frequency (c/deg)
			%	phase:				phase of the grating ([0,2*pi])
			%	degPerPix:			number of degrees per pixel
			%   radius:				radius of the grating (in the middle); uniform grating across whole image if radius < 0
			%	width_or_orient:	width of the circle when radius >= 0 (deg); or orientation of the grating when radius < 0 (deg), 0 indicates vertical
			%
			%   grating:			pixel values of the grating (range of [-1 1]); 1st dimension for vertical, 2nd for horizontal
			%	inputX:				horizontal coordinates of each pixel in img (deg)
			%	inputY:				vertical coordinates of each pixel in img (deg)

			w = 1920; h = 1080;
			grating = zeros(h,w);
			inputX = ( (1:w) - (1+w)/2 ) * degPerPix;
			inputY = ( (1:h) - (1+h)/2 ) * degPerPix;

			if(radius < 0)
				orientation = width_or_orient;
				grating = cos( 2*pi * sf * (inputX * cosd(orientation) + inputY' * sind(orientation)) + phase );
            else
    			r = sqrt( inputX.^2 + inputY'.^2 );
				width = width_or_orient;
				if(radius == 0)
					width = width*2;
				end
				idx = abs(r - radius) < width/2;
				grating(idx) = cos( pi * (r(idx)-radius) / width ) .* cos( 2*pi * sf * (r(idx)-radius) + phase );
			end
		end


		function contrasts = ComputeContrasts(obj, img, inputX, inputY, rfX, rfY, rfSurroundRadius, eyeX, eyeY)
			% contrasts:	1st dim for cells, 2nd dim for eye positions

			r = 10 * rfSurroundRadius / sqrt(2);		% 6*std of surround
			nNeurons = length(rfX);
			nEyePos = length(eyeX);
			MAXs = NaN(nNeurons,nEyePos);
			MINs = NaN(nNeurons,nEyePos);
			
			parfor( k = 0 : nNeurons * nEyePos-1 )
		        iEyePos = floor(k/nNeurons) + 1;
		        iNeuron = mod(k,nNeurons) + 1;

		        % square area
		        dX = inputX' - (rfX(iNeuron) + eyeX(iEyePos));
		        dY = inputY - (rfY(iNeuron) + eyeY(iEyePos));
		        idxX = abs(dX) <= r(iNeuron);
		        idxY = abs(dY) <= r(iNeuron);
		        MAX = max( max( img(idxY, idxX) ) );
		        MIN = min( min( img(idxY, idxX) ) );
		        if( ~isempty(MAX) )
		        	MAXs(k+1) = MAX;
		        	MINs(k+1) = MIN;
		        end
		    end

		    contrasts = (MAXs - MINs) ./ (MAXs + MINs);
		    contrasts(isnan(contrasts)) = 0;
		end


		function DisplayMosaics(obj, radius)
			% figure( 'NumberTitle', 'off', 'name', 'Mosaics', 'color', 'k' );
			colors = {'r', 'b', 'm', 'c'};
			for( k = 1 : size(obj.layers,2) )
				figure( 'NumberTitle', 'off', 'name', sprintf( 'Mosaics | %s | [%.1f, %.1f]', obj.layers(k).name, -radius, radius ), 'color', 'k' );
				% subplot(2,2,k);
				plot( obj.layers(k).locations(:,1), obj.layers(k).locations(:,2), '.', 'color', colors{k}, 'markersize', 4 );
				% title( obj.layers(k).name );
				text( 0, radius*1.02, obj.layers(k).name, 'horizontalAlignment', 'center', 'verticalAlignment', 'bottom', 'fontsize', 20, 'color', 'w' );
				axis equal;
				set( gca, 'xlim', [-radius radius], 'ylim', [-radius radius], 'fontsize', 20, 'visible', 'off', 'color', 'k', 'xcolor', 'w', 'ycolor', 'w' );
			end
		end


		%% Video4ExampleCells
		function Video4ExampleCells(obj, saveFolder)
			if(~exist('saveFolder', 'var') || isempty(saveFolder))
				saveFolder = '../../Data/videos';
			end
			if(~exist(saveFolder, 'dir'))
				mkdir(saveFolder);
			end

			conditions = obj.activityParams.conditions;
			time = obj.activityParams.timeline;
			Eccs = unique([conditions.eccentricity]);
			nEccs = size(Eccs,2);
			SFs = [0, 2, 10];
			contrasts = [0, 0.5, 0.5];
			colors = { [1 0 0], [0 0 1], [1 0 1], [0 1 1] };

			trials = obj.activityParams.trials;
			iTrial = 1;
			fr = [obj.layers.LFR];
			fr = max(0, reshape(cat(1, fr{:}), 1, []));
			fr(isnan(fr)) = [];
			frMax = std(fr)*5;

			%% get average radii
			for(iL = 4:-1:1)
				for(iEcc = size(Eccs,2) : -1 : 1)
					Radii(iL,iEcc) = mean( [obj.layers(iL).sRFParams(obj.layers(iL).idxExampleCells{iEcc}).centerRadii] ) / 2;
				end
			end

			%%
			for( iCont = 1 : size(contrasts,2) )

				filename = fullfile(saveFolder, sprintf('contrast=%.2f, SF=%d', contrasts(iCont), SFs(iCont)));
				writerObj = VideoWriter(filename, 'MPEG-4');
				open(writerObj);

				figure( 'NumberTitle', 'off', 'color', 'k', 'name', sprintf('Movie: contrast=%0.2f, SF=%d', contrasts(iCont), SFs(iCont)) );
				pause(0.1);
				jf = get(handle(gcf),'javaframe');
				jf.setMaximized(1);
				pause(1);
				for( iEcc = 1 : size(Eccs,2) )
					for( iL = 1 : 4 )
						subplot(nEccs, 4, (iEcc-1)*4 + iL); hold on;
						set( gca, 'fontsize', 20, 'linewidth', 2, 'color', 'k', 'XColor', 'w', 'YColor', 'w' );
						axis equal;
					end
				end

				tStart = -50;
				for( iTick = find(time == tStart) : size(time,2) )

					% create graphic objects
					if( iTick == find(time == tStart) )
						for( iEcc = 1 : size(Eccs,2) )
							for( iL = 1 : 4 )
								subplot(nEccs, 4, (iEcc-1)*4 + iL);
								title(sprintf('%s | Ecc=%d | t=%dms', obj.layers(iL).name, Eccs(iEcc), time(iTick)), 'color', 'w');
								
								cellCenter{iL,iEcc} = mean(obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}, :), 1);
								eyeIdx = round(time(iTick)/1000*trials(iTrial).sRate) + trials(iTrial).(conditions(1).alignEvent) + (-10:0);
								if(iEcc == 1)
									ecc = 0.75;
								else
									ecc = Eccs(iEcc);
								end
								hEye{iL,iEcc} = plot( -trials(iTrial).x.position(eyeIdx)/60 + ecc, -trials(iTrial).y.position(eyeIdx)/60, 'w-', 'linewidth', 1 );
								% hEye{iL,iEcc} = plot( cellCenter{iL,iEcc}(1) + trials(iTrial).x.position(eyeIdx)/60, cellCenter{iL,iEcc}(2) + trials(iTrial).y.position(eyeIdx)/60, 'w-', 'linewidth', 1 );

								for( iCell = 1 : size(obj.layers(iL).idxExampleCells{iEcc},1) )
									r = Radii(iL,iEcc);
									iCond = [conditions.eccentricity] == Eccs(iEcc) & [conditions.sf] == SFs(iCont);
									h{iL,iEcc}(iCell) = fill( r*cosd(0:60:300)+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 1), r*sind(0:60:300)+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 2),...
																	'k', 'FaceColor', 'k', 'FaceAlpha', 0.5, 'LineStyle', 'none' );
									% h{iL,iEcc}(iCell) = fill( r*cosd(0:60:300)+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 1) + trials(iTrial).x.position(eyeIdx(end))/60, ...
									% 						  r*sind(0:60:300)+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 2) + trials(iTrial).y.position(eyeIdx(end))/60,...
									% 								'k', 'FaceColor', 'k', 'FaceAlpha', 0.5, 'LineStyle', 'none' );
								end
							end
						end
						drawnow;
					end

					% update graphic objects for each time point
					for( iEcc = 1 : size(Eccs,2) )
			            iCond = [conditions.eccentricity] == Eccs(iEcc) & [conditions.sf] == SFs(iCont);
						
						for( iL = 1 : 4 )
							subplot(nEccs, 4, (iEcc-1)*4 + iL);
							title(sprintf('%s | Ecc=%d | t=%dms', obj.layers(iL).name, Eccs(iEcc), time(iTick)), 'color', 'w');

							eyeIdx = round(time(iTick)/1000*trials(iTrial).sRate) + trials(iTrial).(conditions(1).alignEvent) + (-10:0);
							if(iEcc == 1)
								ecc = 0.75;
							else
								ecc = Eccs(iEcc);
							end
							hEye{iL,iEcc}.XData = -trials(iTrial).x.position(eyeIdx)/60 + ecc;
							hEye{iL,iEcc}.YData = -trials(iTrial).y.position(eyeIdx)/60;
							% hEye{iL,iEcc}.XData = cellCenter{iL,iEcc}(1) + trials(iTrial).x.position(eyeIdx)/60;
							% hEye{iL,iEcc}.YData = cellCenter{iL,iEcc}(2) + trials(iTrial).y.position(eyeIdx)/60;
								
							for( iCell = 1 : size(obj.layers(iL).idxExampleCells{iEcc},1) )
								h{iL,iEcc}(iCell).FaceColor = colors{iL} * min( 1, max(0, obj.layers(iL).LFR{iCond}(iCell,iTick,iTrial)) / frMax );
								% h{iL,iEcc}(iCell).Vertices = [ Radii(iL,iEcc)*cosd(0:60:300)'+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 1) + trials(iTrial).x.position(eyeIdx(end))/60, ...
								% 							   Radii(iL,iEcc)*sind(0:60:300)'+obj.layers(iL).locations(obj.layers(iL).idxExampleCells{iEcc}(iCell), 2) + trials(iTrial).y.position(eyeIdx(end))/60 ];
							end
							
						end
					end
					drawnow;
					writeVideo(writerObj, getframe(gcf));
					% pause;
				end

				close(writerObj);
			end
		end
		
	end
end